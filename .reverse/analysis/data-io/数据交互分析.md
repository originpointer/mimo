# Mimo 网络请求与架构分析

## 1. 从网络请求中获取的信息

### 1.1 Background Socket.IO 消息 (端口 6007)

基于 `接口分析.md` 中的日志，可以提取以下信息：

#### 连接阶段
```json
{
  "sid": "l_lfXstLcqmRiOgEHbAd",
  "upgrades": [],
  "pingInterval": 25000,
  "pingTimeout": 20000,
  "maxPayload": 2097152
}
```

**属性说明：**

| 属性 | 说明 |
|------|------|
| `sid` | Socket.IO 会话 ID，唯一标识一个连接 |
| `upgrades` | 传输协议升级列表（如 websocket → HTTP long-polling） |
| `pingInterval` | 心跳间隔（毫秒），客户端定期发送 ping |
| `pingTimeout` | 心跳超时（毫秒），服务端未响应则认为断线 |
| `maxPayload` | 单条消息最大字节数限制 |

#### 扩展激活信息
```json
{
  "type": "activate_extension",
  "id": "7GhpFtXTftMrPsDTn5byTV",
  "clientId": "799d1683-daa4-4a5d-82e3-3d14ff199815",
  "ua": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) ...",
  "version": "0.0.47",
  "browserName": "Smart-Fox",
  "allowOtherClient": true,
  "skipAuthorization": true
}
```

**属性说明：**

| 属性 | 说明 |
|------|------|
| `id` | 消息唯一标识符，用于请求-响应匹配 |
| `clientId` | 客户端唯一标识，浏览器实例级别 |
| `ua` | User-Agent 浏览器标识字符串 |
| `version` | 插件版本号 |
| `browserName` | 浏览器名称（用户自定义，如 "Smart-Fox"） |
| `allowOtherClient` | 是否允许其他客户端接管控制 |
| `skipAuthorization` | 是否跳过授权验证（开发模式） |

#### 会话信息
```json
{
  "type": "session_status",
  "sessionId": "4Kew4F3EqyaTgrO03q341l",
  "sessionTitle": "如何使用浏览器打开http://localhost:5173/页面",
  "status": "running" | "stopped",
  "timestamp": 1769742642671
}
```

**属性说明：**

| 属性 | 说明 |
|------|------|
| `sessionId` | 会话唯一标识，贯穿整个任务流程 |
| `sessionTitle` | 会话标题，用户原始请求的摘要 |
| `status` | 会话状态：`running`(进行中) / `stopped`(已停止) |
| `timestamp` | Unix 时间戳（毫秒） |

#### 浏览器操作指令
```json
{
  "type": "browser_action",
  "action": {
    "browser_navigate": {
      "brief": "尝试打开 http://localhost:5173/ 页面",
      "intent": "navigational",
      "url": "http://localhost:5173/",
      "append_manusai_user": true
    }
  },
  "screenshot_presigned_url": "https://vida-private.s3...",
  "clean_screenshot_presigned_url": "https://vida-private.s3..."
}
```

**属性说明：**

| 属性 | 作用 |
|------|------|
| `brief` | 操作简短描述，用于前端展示 |
| `intent` | 操作意图类型：`navigational`(导航) / `interaction`(交互) |
| `append_manusai_user` | 是否在 URL 中附加 Manus 用户标识（用于统计） |
| `screenshot_presigned_url` | 用于上传**标记截图**（包含 AI 分析标注，如元素高亮、选框等） |
| `clean_screenshot_presigned_url` | 用于上传**原始截图**（纯净版，无任何标注） |

**工作流程：**
1. 后端生成两个 AWS S3 pre-signed URL
2. 通过 Socket.IO 发送给插件
3. 插件执行浏览器操作后捕获两张截图
4. 插件使用 pre-signed URL 直接 PUT 上传到 S3
5. 前端通过 S3 URL 展示截图

**双截图设计原因：**
- 标记截图：用于前端展示分析结果，帮助用户理解 AI 识别的元素
- 清理截图：保留原始页面状态，用于其他用途或对比查看

#### 执行结果
```json
{
  "status": "success",
  "result": {
    "url": "http://localhost:5173/",
    "title": "vite-project",
    "elements": "[:]{div {id:\"root\"} ...}",
    "markdown": "# vite-project\n\nVite + React...",
    "full_markdown": "...",
    "viewport_width": 1472,
    "viewport_height": 836,
    "pixels_above": 0,
    "pixels_below": 0,
    "new_pages": []
  }
}
```

**属性说明：**

| 属性 | 说明 |
|------|------|
| `elements` | 可访问元素的紧凑表示（用于快速解析） |
| `markdown` | 页面内容的 Markdown 格式摘要 |
| `full_markdown` | 完整的页面内容 Markdown（包含所有元素） |
| `viewport_width/height` | 浏览器视口尺寸（像素） |
| `pixels_above/below` | 视口上下不可见的像素高度（用于滚动判断） |
| `new_pages` | 操作后打开的新页面列表（如弹窗） |

### 1.2 S3 截图上传

通过 `PUT` 请求上传截图到 AWS S3：
- **标记截图**: `*_bWFya2Vk.webp` (包含标记的截图)
- **清理截图**: `*_Y2xlYW4.webp` (原始截图)

### 1.3 Manus.im Socket.IO 消息

包含更多前端相关事件：

| 事件类型 | 说明 | 示例内容 |
|---------|------|----------|
| `message` | 用户消息 | `{"type": "user_message", "content": "..."}` |
| `chatDelta` | 流式文本增量 | `{"delta": {"content": "好的，我..."}}` |
| `liveStatus` | 实时状态 | `{"text": "思考中"}` |
| `planUpdate` | 任务计划更新 | `{"tasks": [{"status": "doing", "title": "..."}]}` |
| `explanation` | AI 思考过程 | `{"content": "我已成功...", "status": "streaming"}` |
| `toolUsed` | 工具使用事件 | `{"tool": "browser", "status": "success"}` |
| `statusUpdate` | 代理状态 | `{"agentStatus": "running"}` |
| `myBrowserSelection` | 浏览器选择 | `{"status": "waiting_for_selection"}` |
| `queueStatusChange` | 队列状态 | `{"queueStatus": "done"}` |
| `sandboxUpdate` | 沙箱更新 | `{"sandboxId": "...", "status": "running"}` |
| `taskModeChanged` | 任务模式切换 | - |

---

## 2. 插件与前端页面的分工

### 2.1 插件 (Plasmo Extension / Background)

**职责：**
- Socket.IO 连接管理
- 消息路由分发
- 浏览器自动化执行 (CDP)
- Tab 管理
- 截图上传

**处理的命令类型：**
- `browser_navigate` - 页面导航
- `browser_click` - 元素点击
- `browser_fill` - 表单填充
- `browser_screenshot` - 截图捕获
- `browser_getContent` - 获取页面内容
- DOM 操作相关命令 (`dom.observe`, `dom.locator`, `dom.mark`)

**关键特点：**
- 始终在后台运行 (Service Worker)
- 保持与后端的持久 WebSocket 连接
- 拥有完整的浏览器 API 权限
- 不直接展示 UI

### 2.2 前端页面 (Manus.im)

**职责：**
- 用户界面展示
- 聊天交互
- HTTP API 调用
- 结果可视化
- 流式响应处理 (SSE)

**处理的内容：**
- 用户输入和指令
- AI 对话展示
- 任务进度显示
- 截图预览
- 浏览器选择 UI

**通信方式：**
```
前端 → HTTP POST → 后端 API → Socket.IO → 插件
前端 ← HTTP Response ← 后端 API ← Socket.IO ← 插件
```

### 2.3 分工对比表

| 维度 | 插件 (Background) | 前端页面 (Frontend) |
|------|-------------------|---------------------|
| **运行环境** | Chrome Extension Service Worker | Browser Tab / Web App |
| **用户交互** | 无 UI | 完整 UI |
| **浏览器权限** | 完整权限 | 受限 |
| **CDP 访问** | ✅ 支持 | ❌ 不支持 |
| **持久连接** | ✅ WebSocket (后台) | ❌ 页面关闭断开 |
| **主要协议** | Socket.IO (6007) | HTTP API + Socket.IO |
| **数据处理** | 执行命令 | 展示结果 |
| **截图** | 捕获并上传 | 展示 |
| **DOM 操作** | 直接操作 | 无 |

---

## 3. 后端通信决策逻辑

### 3.1 发送到插件端

**时机：** 需要操作浏览器或获取浏览器数据时

**事件名：** `my_browser_extension_message`

**场景示例：**

```json
// 1. 用户请求导航
{
  "type": "browser_action",
  "action": {
    "browser_navigate": {
      "brief": "尝试打开页面",
      "intent": "navigational",
      "url": "http://localhost:5173/"
    }
  }
}

// 2. 用户请求点击元素
{
  "type": "browser_action",
  "action": {
    "browser_click": {
      "selector": "#submit-button"
    }
  }
}

// 3. 获取页面内容
{
  "type": "browser_get_content"
}
```

**支持的命令类型：**
- `browser_navigate` - 导航到 URL
- `browser_click` - 点击元素
- `browser_fill` - 填充表单
- `browser_screenshot` - 截图
- `browser_getContent` - 获取内容
- `browser_evaluate` - 执行 JS
- `browser_hover` - 悬停
- `browser_select` - 选择下拉
- `browser_close` - 关闭标签

### 3.2 发送到前端页面

**时机：** 需要更新 UI 或展示结果时

**事件名：** `message`

**场景示例：**

```json
// 1. 任务状态更新
{
  "type": "session_status",
  "status": "running" | "stopped",
  "sessionId": "...",
  "sessionTitle": "..."
}

// 2. AI 流式响应
{
  "type": "chatDelta",
  "delta": {
    "content": "好的，我这就为您打开..."
  },
  "sender": "assistant"
}

// 3. 实时状态
{
  "type": "liveStatus",
  "text": "思考中" | "使用浏览器" | "等待用户响应"
}

// 4. 计划更新
{
  "type": "planUpdate",
  "tasks": [
    {"status": "doing", "title": "打开本地服务页面"},
    {"status": "todo", "title": "向用户报告页面状态"}
  ]
}

// 5. 截图结果
{
  "type": "toolUsed",
  "tool": "browser",
  "status": "success",
  "detail": {
    "browser": {
      "screenshot": "https://...",
      "url": "http://localhost:5173/"
    }
  }
}

// 6. 浏览器选择
{
  "type": "myBrowserSelection",
  "status": "waiting_for_selection",
  "browser_candidates": [
    {"client_id": "...", "client_name": "Smart-Fox"},
    {"client_id": "...", "client_name": "Swift-Phoenix"}
  ]
}
```

### 3.3 通信决策树

```
用户请求
    │
    ├─ 需要 CDP 操作?
    │   └─ YES → 发送到插件
    │       ├── browser_navigate
    │       ├── browser_click
    │       ├── browser_fill
    │       └── browser_screenshot
    │
    ├─ 需要更新 UI?
    │   └─ YES → 发送到前端
    │       ├── session_status
    │       ├── liveStatus
    │       ├── planUpdate
    │       └── chatDelta
    │
    └─ 需要浏览器选择?
        └─ YES → 发送到前端
            └── myBrowserSelection (等待用户选择)
```

### 3.4 通信协议对比

| 维度 | 后端 → 插件 | 后端 → 前端 |
|------|-------------|-------------|
| **Socket.IO 事件** | `my_browser_extension_message` | `message` |
| **数据类型** | 命令指令 | UI 更新 |
| **响应方式** | 直接返回执行结果 | 事件推送 |
| **示例** | `{ type: "browser_action" }` | `{ type: "liveStatus" }` |

---

## 4. 完整数据流示例

### 示例：用户请求 "使用浏览器打开 http://localhost:5173/"

```
1. 用户在 Manus.im 输入请求
   └─→ 前端发送 message 事件
       { type: "user_message", content: "使用浏览器打开..." }

2. 后端接收并处理
   └─→ 发送 liveStatus: "思考中"
   └─→ 发送 planUpdate: 创建任务列表
   └─→ 发送 explanation: AI 思考过程 (流式)
   └─→ 发送 toolUsed: { tool: "browser", status: "start" }

3. 后端发现需要浏览器
   └─→ 发送 myBrowserSelection
   └─→ 前端显示浏览器选择 UI
       {"browser_candidates": [...]}

4. 用户选择浏览器 "Smart-Fox"
   └─→ 前端发送 select_my_browser 事件
       { targetClientId: "799d1683-daa4-4a5d-82e3-3d14ff199815" }

5. 后端向插件发送导航命令
   └─→ Socket.IO: my_browser_extension_message
       {
         type: "browser_action",
         action: {
           browser_navigate: {
             url: "http://localhost:5173/",
             brief: "尝试打开...",
             screenshot_presigned_url: "https://s3..."
           }
         }
       }

6. 插件执行导航
   └─→ CDP: Page.navigate(url)
   └─→ 等待页面加载 (load event)
   └─→ 捕获截图
   └─→ 获取页面内容 (DOM → markdown)
   └─→ 上传截图到 S3 (PUT request)

7. 插件返回结果
   └─→ Socket.IO response:
       {
         status: "success",
         result: {
           url: "http://localhost:5173/",
           title: "vite-project",
           elements: "...",
           markdown: "# vite-project...",
           viewport_width: 1472,
           viewport_height: 836
         }
       }

8. 后端转发结果到前端
   └─→ toolUsed: { status: "success", detail: { browser: {...} } }
   └─→ liveStatus: "查看浏览器"
   └─→ planUpdate: 任务标记为 done

9. AI 生成最终响应
   └─→ chatDelta (流式): "我已成功为您打开了 http://localhost:5173/..."
   └─→ statusUpdate: agentStatus = "stopped"
```

### 数据流图

```
┌─────────────┐         ┌─────────────┐         ┌─────────────┐
│   Manus.im  │         │   后端      │         │  Extension  │
│   (前端)    │         │  (Backend)  │         │  (插件)     │
└──────┬──────┘         └──────┬──────┘         └──────┬──────┘
       │                       │                       │
       │ 1. user_message       │                       │
       ├──────────────────────>│                       │
       │                       │                       │
       │ 2. liveStatus         │                       │
       │    planUpdate         │                       │
       │    chatDelta          │                       │
       │<──────────────────────┤                       │
       │                       │                       │
       │ 3. myBrowserSelection │                       │
       │<──────────────────────┤                       │
       │                       │                       │
       │ 4. select_my_browser  │                       │
       ├──────────────────────>│                       │
       │                       │                       │
       │                       │ 5. browser_action     │
       │                       ├──────────────────────>│
       │                       │                       │
       │                       │                       │ 6. CDP Execute
       │                       │                       │    (navigate)
       │                       │                       │
       │                       │                       │ 7. Upload S3
       │                       │                       │
       │                       │ 8. result             │
       │                       │<──────────────────────┤
       │                       │                       │
       │ 9. toolUsed           │                       │
       │    screenshot         │                       │
       │<──────────────────────┤                       │
       │                       │                       │
       │ 10. chatDelta (最终)  │                       │
       │<──────────────────────┤                       │
```

---

## 5. 总结

### 后端发送到插件的条件：

| 条件 | 说明 |
|------|------|
| ✅ 需要使用 Chrome DevTools Protocol (CDP) | 所有浏览器自动化操作 |
| ✅ 需要操作浏览器 Tab | 打开、关闭、切换标签 |
| ✅ 需要获取页面 DOM 内容 | 解析页面结构 |
| ✅ 需要截图 | 捕获页面视觉 |
| ✅ 需要执行浏览器自动化操作 | 点击、填充、滚动等 |

### 后端发送到前端页面的条件：

| 条件 | 说明 |
|------|------|
| ✅ 需要更新 UI 状态 | 任务状态、代理状态 |
| ✅ 需要展示 AI 响应 | 包括流式文本 |
| ✅ 需要显示任务进度 | 计划步骤更新 |
| ✅ 需要用户交互 | 选择浏览器、确认操作 |
| ✅ 需要展示截图或结果 | 截图预览、页面内容 |

### 通信协议总结：

| 通信方向 | 协议 | 说明 |
|----------|------|------|
| 后端 ↔ 插件 | Socket.IO | namespace `/mimo`，事件 `my_browser_extension_message` |
| 后端 ↔ 前端 | Socket.IO | 事件 `message` |
| 前端 → 后端 | HTTP API | REST API |
| 前端 ↔ 插件 | chrome.runtime | 扩展消息传递 |
