# 认证助手 (AuthHelper) 详细分析

## 类信息

**原始类名**: `AuthHelper`
**压缩后名称**: `mn`
**文件**: background.ts.js
**行号**: 59-195

## 概述

`AuthHelper` 负责管理扩展与 Manus Web 应用之间的认证同步。它监听用户在 manus.im 上的登录状态，并将认证 Cookie 同步到扩展的本地存储。

## 类结构

```javascript
class AuthHelper {
  constructor() {
    this.cleanupWatcher = null           // 清理函数
    this.debounceTimers = new Map()      // 防抖定时器
  }
}
```

## 核心方法

### 1. initialize() - 初始化

```javascript
async initialize() {
  try {
    // 步骤 1: 确保浏览器设置存在
    const settings = BrowserSettings.getBrowserSettings()
    if (!settings || !settings.browserName) {
      await BrowserSettings.setBrowserSettings(DEFAULT_SETTINGS)
    }

    // 步骤 2: 读取 Manus 应用的 Cookie
    const cookies = await this.getManusAppCookies()

    logger.info("Manus app cookies obtained", { cookies })

    // 步骤 3: 同步 session_id Cookie 到令牌存储
    if (cookies.token) {
      const normalized = this.normalizeValue(cookies.token)
      await Token.setToken(normalized)
    } else {
      logger.info("No token found in cookies")
    }

    // 步骤 4: 同步 devBranch Cookie
    if (cookies.devBranch) {
      const normalized = this.normalizeValue(cookies.devBranch)
      await DevBranch.setDevBranch(normalized)
    } else {
      logger.info("No devBranch found in cookies")
    }

    return {
      token: this.normalizeValue(cookies.token),
      initialized: true
    }
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error)
    logger.error("Failed to initialize auth", { error: errorMsg })

    return {
      token: null,
      initialized: false
    }
  }
}
```

### 2. startWatcher() - 启动 Cookie 监听

```javascript
startWatcher() {
  // 检查 chrome.cookies API 是否可用
  if (!chrome.cookies?.onChanged) {
    logger.warn("chrome.cookies API unavailable; skip Manus cookies watcher")
    return
  }

  // 停止现有的监听器
  this.stopWatcher()

  // 获取 Manus 应用域名
  const webAppDomain = Environment.getEnvParams().webAppDomain
  let hostname

  try {
    hostname = new URL(webAppDomain).hostname
  } catch (error) {
    logger.error("Failed to start Manus cookies watcher; invalid URL", {
      url: webAppDomain,
      error: error instanceof Error ? error.message : String(error)
    })
    return
  }

  // 定义要监听的 Cookie 配置
  const cookiesToWatch = [
    {
      cookieName: "session_id",
      getCurrentValue: () => Token.getToken(),
      setValue: (value) => Token.setToken(value)
    }
  ]

  // Cookie 变更监听器
  const listener = (changeInfo) => {
    const { cookie, removed } = changeInfo

    if (!cookie) return

    // 验证 Cookie 域名
    const cookieDomain = cookie.domain.startsWith(".")
      ? cookie.domain.slice(1)
      : cookie.domain

    if (hostname !== cookieDomain && !hostname.endsWith(`.${cookieDomain}`)) {
      return  // 不是 Manus 域名的 Cookie
    }

    // 查找匹配的监听配置
    const watcher = cookiesToWatch.find(w => w.cookieName === cookie.name)
    if (watcher) {
      this.handleCookieChangeWithDebounce(
        cookie.name,
        removed,
        cookie.value,
        watcher
      )
    }
  }

  // 添加监听器
  chrome.cookies.onChanged.addListener(listener)

  logger.info("Started watching Manus app cookies", {
    host: hostname,
    cookies: cookiesToWatch.map(c => c.cookieName)
  })

  // 保存清理函数
  this.cleanupWatcher = () => {
    chrome.cookies.onChanged.removeListener(listener)

    // 清除所有防抖定时器
    for (const timer of this.debounceTimers.values()) {
      clearTimeout(timer)
    }
    this.debounceTimers.clear()

    logger.info("Stopped watching Manus app cookies", {
      host: hostname,
      cookies: cookiesToWatch.map(c => c.cookieName)
    })
  }
}
```

### 3. stopWatcher() - 停止监听

```javascript
stopWatcher() {
  if (this.cleanupWatcher) {
    this.cleanupWatcher()
    this.cleanupWatcher = null
  }
}
```

### 4. getManusAppCookies() - 获取 Cookie

```javascript
async getManusAppCookies() {
  const webAppDomain = Environment.getEnvParams().webAppDomain

  // 并行读取两个 Cookie
  const [tokenCookie, devBranchCookie] = await Promise.all([
    new Promise((resolve, reject) => {
      chrome.cookies.get({
        url: webAppDomain,
        name: "session_id"
      }, (cookie) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message))
          return
        }
        resolve(cookie)
      })
    }),

    new Promise((resolve, reject) => {
      chrome.cookies.get({
        url: webAppDomain,
        name: "devBranch"
      }, (cookie) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message))
          return
        }
        resolve(cookie)
      })
    })
  ])

  return {
    token: tokenCookie?.value ?? null,
    devBranch: devBranchCookie?.value ?? null
  }
}
```

### 5. handleCookieChangeWithDebounce() - 防抖处理

```javascript
handleCookieChangeWithDebounce(cookieName, removed, value, config) {
  // 清除现有的防抖定时器
  const existingTimer = this.debounceTimers.get(cookieName)
  if (existingTimer) {
    clearTimeout(existingTimer)
  }

  // 计算新值（移除的 Cookie 为 null）
  const nextValue = removed ? null : this.normalizeValue(value)

  // 设置新的防抖定时器（500ms）
  const newTimer = setTimeout(async () => {
    const currentValue = config.getCurrentValue()

    // 仅在值实际变化时才更新
    if (nextValue !== currentValue) {
      logger.info(`Manus ${cookieName} cookie changed (debounced)`, {
        removed,
        nextValue,
        currentValue
      })

      await config.setValue(nextValue).catch(error => {
        logger.error(`Failed to sync ${cookieName} from cookie change`, {
          removed,
          error: error instanceof Error ? error.message : String(error)
        })
      })
    }

    // 删除定时器引用
    this.debounceTimers.delete(cookieName)
  }, 500)

  // 保存定时器引用
  this.debounceTimers.set(cookieName, newTimer)
}
```

### 6. normalizeValue() - 值规范化

```javascript
normalizeValue(value) {
  if (typeof value !== "string") {
    return null
  }

  const trimmed = value.trim()
  return trimmed.length > 0 ? trimmed : null
}
```

## 认证流程图

```
┌─────────────────────────────────────────────────────────────────────┐
│                        用户登录流程                                  │
└─────────────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│                     1. 用户访问 manus.im                            │
│                     2. 登录成功                                      │
│                     3. 后端设置 session_id Cookie                   │
└─────────────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│              chrome.cookies.onChanged 事件触发                       │
│              { cookie: { name: "session_id", value: "abc..." } }    │
└─────────────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│              AuthHelper.handleCookieChangeWithDebounce()            │
│              - 500ms 防抖定时器                                      │
│              - 域名验证 (manus.im)                                   │
└─────────────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│              Token.setToken("abc...")                               │
│              - 写入 chrome.storage.local                            │
│              - 键: manus_extension_token                            │
└─────────────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│              跨上下文同步                                            │
│              - Background: ✓ 收到变更                               │
│              - manus.im 页面: ✓ 通过 ManusAppBridge 收到            │
│              - Content: ✗ 无访问权限                                │
└─────────────────────────────────────────────────────────────────────┘

> **说明 (2026-01-29)**: 原分析中错误地引用了不存在的 "sidepanel"。实际 UI 位于 manus.im 网站，通过 ManusAppBridge (注入到 manus.im 的 Content Script) 接收更新。详见 [sidepanel实现方式发现报告.md](../../09_重要发现/sidepanel实现方式发现报告.md)。
```

## Cookie 映射关系

| Cookie 属性 | Chrome Cookie | 扩展存储 |
|------------|--------------|---------|
| 名称 | `session_id` | `manus_extension_token` |
| 域名 | `.manus.im` | - |
| 路径 | `/` | - |
| 安全 | `true` (HTTPS) | - |
| HttpOnly | `true` | - |
| SameSite | `Lax` / `Strict` | - |
| 存储位置 | 浏览器 Cookie 存储 | `chrome.storage.local` |

## 防抖机制

### 为什么需要防抖？

1. **避免过度写入**: Cookie 可能快速变化
2. **减少存储操作**: chrome.storage.local 写入相对昂贵
3. **防止竞态条件**: 多个快速变更可能导致状态不一致

### 防抖时间线

```
T=0ms:    Cookie 变更 → 设置 500ms 定时器
T=200ms:  Cookie 再次变更 → 取消旧定时器，设置新 500ms 定时器
T=400ms:  Cookie 再次变更 → 取消旧定时器，设置新 500ms 定时器
T=900ms:  定时器触发 → 同步到存储（距最后一次变更 500ms）
```

## 域名验证逻辑

```javascript
// Cookie 域名 vs Manus 域名匹配规则
const cookieDomain = cookie.domain.startsWith(".")
  ? cookie.domain.slice(1)  // ".manus.im" → "manus.im"
  : cookie.domain           // "manus.im" → "manus.im"

// 匹配条件（满足其一即可）
const isMatch =
  hostname === cookieDomain ||              // 精确匹配: "manus.im" === "manus.im"
  hostname.endsWith(`.${cookieDomain}`)      // 子域名匹配: "app.manus.im".endsWith(".manus.im")

// 示例
"manus.im" === "manus.im"                    // ✅ true
"manus.im".endsWith(".manus.im")             // ❌ false
"app.manus.im".endsWith(".manus.im")         // ✅ true
"evil.com".endsWith(".manus.im")             // ❌ false
```

## 错误处理

### 初始化失败

```javascript
// 返回安全默认值
return {
  token: null,
  initialized: false
}
```

### Cookie 同步失败

```javascript
try {
  await config.setValue(nextValue)
} catch (error) {
  logger.error(`Failed to sync ${cookieName} from cookie change`, {
    removed,
    error: error.message
  })
  // 不抛出异常，继续监听
}
```

## 安全考虑

### ✅ 安全特性

1. **域名验证**: 仅接受来自 manus.im 域名的 Cookie
2. **HttpOnly Cookie**: 原始 Cookie 是 HttpOnly，JS 无法直接访问
3. **值规范化**: trim 并验证空字符串
4. **存储隔离**: Content Script 无法直接访问令牌

### ⚠️ 潜在风险

1. **明文存储**: 令牌以明文存储在 chrome.storage.local
2. **无加密**: 传输中依赖 HTTPS，但本地无加密
3. **无过期时间**: 令牌不过期，依赖 Cookie 生命周期

## 使用示例

```javascript
// 扩展启动时初始化
const authHelper = new AuthHelper()
const { token, initialized } = await authHelper.initialize()

if (initialized) {
  console.log("Token:", token)
  authHelper.startWatcher()
} else {
  console.error("Auth initialization failed")
}

// 扩展关闭时清理
authHelper.stopWatcher()
```

## 调试日志

```javascript
// 初始化
[AuthHelper] Manus app cookies obtained { cookies: { token: "abc...", devBranch: "main" } }

// Cookie 监听开始
[AuthHelper] Started watching Manus app cookies { host: "manus.im", cookies: ["session_id"] }

// Cookie 变更（防抖后）
[AuthHelper] Manus session_id cookie changed (debounced) { removed: false, nextValue: "new-token...", currentValue: "old-token..." }

// Cookie 监听停止
[AuthHelper] Stopped watching Manus app cookies { host: "manus.im", cookies: ["session_id"] }
```
