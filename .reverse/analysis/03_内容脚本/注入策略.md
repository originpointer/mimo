# 内容脚本注入策略分析

## 文件信息

**文件路径**: `/sources/0.0.47_0/content.ts.js`
**文件大小**: 120KB（压缩后）
**美化后**: 约 5000+ 行
**类型**: TypeScript 编译为 JavaScript (ES6 模块)

## 概述

Content Script 是注入到所有网页中的脚本，负责：
1. DOM 元素分析和选择
2. 用户交互模拟（点击、输入、滚动）
3. 页面状态跟踪
4. 与后台工作器通信
5. 视觉反馈（蓝色效果遮罩）

## 注入策略

### Manifest 配置

```json
{
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["assets/content.ts-loader.js"],
      "run_at": "document_start",
      "all_frames": false
    }
  ]
}
```

### Loader 脚本

**文件**: `assets/content.ts-loader.js`

```javascript
(function() {
  'use strict';

  const injectTime = performance.now();

  (async () => {
    // 动态导入主 content script
    const { onExecute } = await import(chrome.runtime.getURL("content.ts.js"));

    // 执行初始化
    onExecute?.({
      perf: {
        injectTime: injectTime,
        loadTime: performance.now() - injectTime
      }
    });
  })().catch(console.error);
})();
```

### 注入时机

| 时机 | 描述 | 优势 |
|------|------|------|
| `document_start` | DOM 构建前注入 | 可以尽早拦截事件、修改 DOM |
| `document_end` | DOM 完成后注入 | 可以立即操作 DOM |
| `document_idle` | 浏览器选择时机 | 平衡性能和功能 |

**选择**: `document_start` - 最早注入，确保扩展能捕获所有页面事件。

## 执行流程

```
┌─────────────────────────────────────────────────────────────────┐
│                    1. 页面导航开始                              │
└───────────────────────────────┬─────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│              2. Chrome 注入 Loader Script                       │
│              (document_start, DOM 未构建)                       │
└───────────────────────────────┬─────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│              3. Loader 动态导入 content.ts.js                   │
│              await import(chrome.runtime.getURL(...))           │
└───────────────────────────────┬─────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│              4. content.ts.js 执行 onExecute()                  │
│              - 初始化消息监听器                                 │
│              - 设置页面状态跟踪                                 │
│              - 注入视觉元素（遮罩、状态栏）                     │
└───────────────────────────────┬─────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│              5. 等待来自 Background 的消息                      │
│              - automation/click                                │
│              - automation/type                                 │
│              - automation/scroll                               │
│              - page/check-ready                                │
└─────────────────────────────────────────────────────────────────┘
```

## 主要类架构

### 状态管理类 (lt)

```javascript
class StateManager {
  constructor() {
    this.currentState = "idle"  // idle, hidden, ongoing, takeover
    this.sessionId = null
  }

  setState(newState) {
    const oldState = this.currentState
    this.currentState = newState

    // 状态变化时更新 UI
    this.updateUI()

    // 通知 background
    chrome.runtime.sendMessage({
      source: "content",
      type: "content/state-changed",
      data: { oldState, newState: newState }
    })
  }
}
```

### 状态类型

| 状态 | 描述 | UI 效果 |
|------|------|---------|
| `idle` | 空闲，无活动任务 | 无遮罩 |
| `hidden` | 隐藏，任务暂停 | 无遮罩 |
| `ongoing` | 任务进行中 | 蓝色边框效果 + 状态栏 |
| `takeover` | 用户接管 | 显示"停止任务"按钮 |

## DOM 分析功能

### 元素可见性检查

```javascript
function isElementVisuallyVisible(element) {
  // 1. 检查 display
  const style = window.getComputedStyle(element)
  if (style.display === "none") return false

  // 2. 检查 visibility
  if (style.visibility === "hidden" || style.visibility === "collapse") {
    return false
  }

  // 3. 检查 pointer-events
  if (style.pointerEvents === "none") return false

  // 4. 检查 opacity
  const opacity = parseFloat(style.opacity || "1")
  if (opacity <= 0) return false

  // 5. 检查尺寸
  const rect = element.getBoundingClientRect()
  if (rect.width <= 1 || rect.height <= 1) return false

  // 6. 检查是否在视口内
  if (rect.bottom < 0 || rect.top > window.innerHeight) return false
  if (rect.right < 0 || rect.left > window.innerWidth) return false

  return true
}
```

### 交互元素检测

```javascript
function findInteractiveElements() {
  const selectors = [
    "button",
    "[onclick]",
    "a",
    "input",
    "textarea",
    "select",
    "[contenteditable]",
    "[role="button"]",
    "[role="link"]",
    "[role="checkbox"]",
    "[role="radio"]"
  ]

  const elements = document.querySelectorAll(selectors.join(", "))

  // 过滤不可见元素
  return Array.from(elements).filter(isElementVisuallyVisible)
}
```

### 元素标记

```javascript
const CLICK_FLAG_ATTR = "data-manus_clickable"
const CLICK_ID_ATTR = "data-manus_click_id"

function markClickableElements() {
  const elements = findInteractiveElements()

  elements.forEach((element, index) => {
    // 添加标记属性
    element.setAttribute(CLICK_ID_ATTR, index.toString())
    element.setAttribute(CLICK_FLAG_ATTR, "true")
  })

  return elements.length
}
```

## 页面准备脚本

```javascript
function preparePageArtifacts() {
  // 1. 提取页面内容为 Markdown
  const markdown = extractPageContentAsMarkdown()

  // 2. 查找并标记交互元素
  const interactiveElements = markClickableElements()

  // 3. 计算元素可见性
  const visibleElements = interactiveElements.filter(isElementVisuallyVisible)

  // 4. 为每个元素生成采样点（用于点击）
  const elementsWithSamplePoints = visibleElements.map(el => {
    const rect = el.getBoundingClientRect()
    const samplePoints = buildSamplePoints(rect)
    return {
      element: el,
      rect,
      samplePoints,
      text: getPrimaryText(el)
    }
  })

  return {
    markdown,
    elements: elementsWithSamplePoints,
    viewport: {
      width: window.innerWidth,
      height: window.innerHeight
    }
  }
}
```

### 采样点生成

```javascript
function buildSamplePoints(rect) {
  const TARGET_SAMPLE_SPACING = 5  // 像素间隔
  const MAX_SAMPLE_GRID = 8         // 最大 8x8 网格

  const points = []

  // 在元素区域内生成均匀分布的采样点
  for (let x = 0; x < MAX_SAMPLE_GRID; x++) {
    for (let y = 0; y < MAX_SAMPLE_GRID; y++) {
      const px = rect.left + (rect.width * x) / MAX_SAMPLE_GRID
      const py = rect.top + (rect.height * y) / MAX_SAMPLE_GRID
      points.push({ x: px, y: py })
    }
  }

  return points
}
```

## 交互处理

### 点击操作

```javascript
async function handleClick(params) {
  const { strategy, selector, index, coordinates } = params

  let element
  let clickPoint

  switch (strategy) {
    case "bySelector":
      element = document.querySelector(selector)
      clickPoint = getElementCenter(element)
      break

    case "byIndex":
      element = document.querySelector(`[${CLICK_ID_ATTR}="${index}"]`)
      clickPoint = getElementCenter(element)
      break

    case "byCoordinates":
      clickPoint = { x: coordinates.x, y: coordinates.y }
      element = document.elementFromPoint(clickPoint.x, clickPoint.y)
      break
  }

  // 执行点击
  await performClick(element, clickPoint)
}

async function performClick(element, point) {
  // 滚动到元素可见
  element.scrollIntoView({ behavior: "smooth", block: "center" })

  // 等待滚动完成
  await sleep(300)

  // 创建鼠标事件
  const mouseDown = new MouseEvent("mousedown", {
    bubbles: true,
    cancelable: true,
    clientX: point.x,
    clientY: point.y,
    button: 0
  })

  const mouseUp = new MouseEvent("mouseup", {
    bubbles: true,
    cancelable: true,
    clientX: point.x,
    clientY: point.y,
    button: 0
  })

  const click = new MouseEvent("click", {
    bubbles: true,
    cancelable: true,
    clientX: point.x,
    clientY: point.y,
    button: 0
  })

  // 触发事件
  element.dispatchEvent(mouseDown)
  await sleep(50)
  element.dispatchEvent(mouseUp)
  await sleep(50)
  element.dispatchEvent(click)
}
```

### 输入操作

```javascript
async function handleInput(params) {
  const { target, text, options = {} } = params

  let element
  if (target.selector) {
    element = document.querySelector(target.selector)
  } else if (target.index !== undefined) {
    element = document.querySelector(`[${CLICK_ID_ATTR}="${target.index}"]`)
  }

  // 聚焦元素
  element.focus()

  // 清除现有内容（如需要）
  if (options.clearFirst) {
    element.value = ""
  }

  // 模拟输入
  for (const char of text) {
    const keyDown = new KeyboardEvent("keydown", {
      bubbles: true,
      cancelable: true,
      key: char
    })

    const keyPress = new KeyboardEvent("keypress", {
      bubbles: true,
      cancelable: true,
      key: char
    })

    const keyUp = new KeyboardEvent("keyup", {
      bubbles: true,
      cancelable: true,
      key: char
    })

    element.dispatchEvent(keyDown)
    element.dispatchEvent(keyPress)

    // 更新值（某些输入需要）
    element.value += char
    element.dispatchEvent(new InputEvent("input", { bubbles: true }))

    element.dispatchEvent(keyUp)

    // 延迟
    await sleep(options.delay || 50)
  }

  // 触发 change 事件
  element.dispatchEvent(new Event("change", { bubbles: true }))
}
```

### 滚动操作

```javascript
async function handleScroll(params) {
  const { direction, amount = 100 } = params

  switch (direction) {
    case "up":
      window.scrollBy({ top: -amount, behavior: "smooth" })
      break
    case "down":
      window.scrollBy({ top: amount, behavior: "smooth" })
      break
    case "left":
      window.scrollBy({ left: -amount, behavior: "smooth" })
      break
    case "right":
      window.scrollBy({ left: amount, behavior: "smooth" })
      break
    case "toEnd":
      window.scrollTo({ top: document.body.scrollHeight, behavior: "smooth" })
      break
    case "toTop":
      window.scrollTo({ top: 0, behavior: "smooth" })
      break
  }

  // 等待滚动完成
  await sleep(500)
}
```

## 视觉反馈系统

### 蓝色效果遮罩

```javascript
function showBlueEffectMask() {
  const mask = document.createElement("div")
  mask.className = "manus-action-mask-blue-effects manus-action-mask-visible"

  // 添加边框渐变效果
  const topEdge = document.createElement("div")
  topEdge.className = "manus-action-mask-blue-effects__edge--top"
  mask.appendChild(topEdge)

  // 添加其他边框...

  document.body.appendChild(mask)
}

function hideBlueEffectMask() {
  const mask = document.querySelector(".manus-action-mask-blue-effects")
  if (mask) {
    mask.classList.remove("manus-action-mask-visible")
    setTimeout(() => mask.remove(), 200)
  }
}
```

### 状态栏

```javascript
function showActionBar(message, showStopButton = false) {
  let bar = document.querySelector(".manus-action-mask-action-bar")

  if (!bar) {
    bar = document.createElement("div")
    bar.className = "manus-action-mask-action-bar"
    document.body.appendChild(bar)
  }

  bar.innerHTML = `
    <div class="manus-action-mask-action-bar__left">
      <span class="manus-action-mask-action-bar__icon">⚡</span>
      <span class="manus-action-mask-action-bar__status">${message}</span>
    </div>
    <div class="manus-action-mask-action-bar__right">
      ${showStopButton ? `
        <button class="manus-action-mask-action-bar__button--stop" data-action="stop">
          停止任务
        </button>
      ` : `
        <button class="manus-action-mask-action-bar__button" data-action="takeover">
          接管
        </button>
      `}
    </div>
  `

  bar.classList.add("manus-action-mask-visible")
}
```

## 消息处理

```javascript
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (!isContentMessage(message)) {
    return
  }

  switch (message.type) {
    case "automation/click":
      return handleClick(message.data).then(sendResponse)

    case "automation/type":
      return handleInput(message.data).then(sendResponse)

    case "automation/scroll":
      return handleScroll(message.data).then(sendResponse)

    case "page/check-ready":
      return Promise.resolve({
        ready: isPageReady(),
        url: window.location.href,
        title: document.title
      })

    case "page/event-block":
      toggleEventBlocking(message.data.enabled)
      return Promise.resolve({ ok: true })

    default:
      console.warn("Unknown message type:", message.type)
      return Promise.resolve({ error: "Unknown message type" })
  }

  return true  // 保持消息通道开放以支持异步响应
})
```

## 性能优化

1. **延迟加载**: 仅在需要时创建 UI 元素
2. **事件委托**: 使用事件委托减少监听器数量
3. **节流/防抖**: 对滚动和 resize 事件使用节流
4. **懒计算**: 仅在需要时计算元素位置
5. **缓存**: 缓存 DOM 查询结果

## 关键发现

1. **最早注入**: 使用 `document_start` 确保比页面脚本先执行
2. **视觉反馈**: 蓝色边框效果 + 状态栏让用户知道扩展在工作
3. **多种定位策略**: 支持选择器、索引、坐标三种元素定位方式
4. **用户控制**: 提供"接管"按钮让用户可以随时停止自动化
5. **状态跟踪**: 维护状态机（idle/hidden/ongoing/takeover）
