# 指令传递流程分析

## 概述

本文档详细分析 Manus AI Browser Extension 中页面操作指令的完整传递流程，从用户在 manus.im 网站发起操作到目标页面执行具体动作的整个链路。

---

## 整体架构流程

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         指令传递完整流程                                │
└─────────────────────────────────────────────────────────────────────────┘

┌──────────────────┐
│   manus.im       │  用户操作入口
│   (Web UI)       │
│                  │
│  ┌────────────┐  │
│  │  React UI  │  │  点击 "开始任务"、配置自动化场景
│  └──────┬───────┘  │
└─────────┼──────────┘
          │
          │ ① window.postMessage
          │    (ManusAppBridge 接收)
          ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                   ManusAppBridge (Content Script)                       │
│                   注入到 manus.im 页面                                  │
│                                                                         │
│  - 验证域名 (isManusAppOrigin)                                          │
│  - 验证消息来源 (source: "manus-app")                                    │
│  - 转发到 background                                                    │
└─────────────────────────────────────────┬───────────────────────────────┘
                                          │
                                          │ ② chrome.runtime.sendMessage
                                          ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                        Background Worker                               │
│                        (Service Worker)                                │
│                                                                         │
│  ┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐     │
│  │ ManusAppHandler  │  │ SessionManager   │  │   CdpClient      │     │
│  │ (处理网站消息)    │  │  (会话管理)      │  │  (截图/调试)     │     │
│  └──────────────────┘  └──────────────────┘  └──────────────────┘     │
└─────────────────────────────────────────┬───────────────────────────────┘
                                          │
                    ┌─────────────────────┴─────────────────────┐
                    │                                           │
                    │ ③ chrome.tabs.sendMessage              │ ④ chrome.debugger.sendCommand
                    │                                           │
                    ▼                                           ▼
        ┌───────────────────────┐                   ┌───────────────────────┐
        │  Content Script       │                   │  Chrome DevTools       │
        │  (注入目标网页)        │                   │  Protocol             │
        │                       │                   │                       │
        │  - DOM 交互           │                   │  - 截图                │
        │  - 元素定位           │                   │  - 页面控制            │
        │  - 视觉反馈           │                   │  - JS 执行             │
        └───────────────────────┘                   └───────────────────────┘
```

---

## 第一阶段：用户操作发起 (manus.im → ManusAppBridge)

### 1.1 用户界面

**位置**: `https://manus.im/my-browser` 或类似路径

**技术栈**: React 19 + MobX

### 1.2 消息发送

```javascript
// manus.im 页面中的代码
window.postMessage({
  source: "manus-app",
  type: "session/start",  // 或其他消息类型
  data: {
    taskName: "填写表单",
    options: { /* ... */ }
  },
  requestId: generateUniqueId(),
  messageTimestamp: Date.now()
}, "*")
```

### 1.3 ManusAppBridge 接收处理

**文件**: `ManusAppBridge.ts.js`

```javascript
// 注入到 manus.im 的 content script
window.addEventListener("message", async (event) => {
  // 1. 验证消息来源
  if (event.source !== window) return;

  // 2. 验证域名
  if (!isManusAppOrigin(event.origin)) {
    logger.debug("Manus App Bridge rejected message from unexpected origin", {
      receivedOrigin: event.origin,
      expectedOrigin: Environment.getEnvParams().webAppDomain
    });
    return;
  }

  // 3. 验证消息来源
  const message = event.data;
  if (!message || message.source !== "manus-app") return;

  // 4. 转发到 background
  try {
    const response = await chrome.runtime.sendMessage(message);
    window.postMessage({ ...response, source: "my-browser" }, "*");
  } catch (error) {
    window.postMessage({
      source: "my-browser",
      ok: false,
      requestId: message.requestId,
      error: error.message
    }, "*");
  }
});
```

**域名验证**:

```javascript
// manus.js
function isManusAppOrigin(origin) {
  const { webAppDomain } = Environment.getEnvParams();

  // 生产环境
  if (origin === "https://manus.im") return true;

  // 开发模式：允许本地主机
  if (Environment.isDev()) {
    const url = new URL(origin);
    const isLocalhost =
      url.hostname === "localhost" ||
      url.hostname === "127.0.0.1" ||
      url.hostname === "::1";

    if (url.protocol === "http:" && isLocalhost) {
      return true;
    }
  }

  return false;
}
```

---

## 第二阶段：Background 处理 (ManusAppBridge → Background)

### 2.1 消息路由

**文件**: `background.ts.js`

```javascript
// Background Worker 中的消息路由
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  // 类型守卫验证
  if (isManusAppMessage(message)) {
    return manusAppHandler.handleMessage(message, sender)
      .then(result => sendResponse(result))
      .catch(error => sendResponse({ ok: false, error: error.message }));
    return true; // 异步响应
  }

  if (isContentMessage(message)) {
    return contentHandler.handleMessage(message, sender)
      .then(result => sendResponse(result))
      .catch(error => sendResponse({ ok: false, error: error.message }));
    return true;
  }

  // ... 其他处理器
});
```

### 2.2 ManusAppHandler 处理

**类**: `Vn` (压缩后) / `ManusAppHandler`

**支持的消息类型**:

| 消息类型 | 功能 | 实现方法 |
|---------|------|---------|
| `my-browser/ping` | 连接检测 | 返回浏览器设置 |
| `my-browser/switch-to-tab` | 切换标签页 | `chrome.tabs.update(tabId, { active: true })` |
| `my-browser/set-browser-settings` | 更新设置 | `BrowserSettings.setBrowserSettings()` |
| `session/start` | 开始会话 | `SessionManager.startSession()` |
| `automation/run-scenario` | 运行场景 | `ScenarioRunner.execute()` |

**示例处理流程**:

```javascript
class ManusAppHandler {
  async handleMessage(message, sender) {
    // 域名验证（二次验证）
    const senderUrl = sender.url;
    if (!senderUrl || !this.isAllowedOrigin(senderUrl)) {
      logger.warn("Message rejected: no sender URL");
      return this.reply(message.requestId, false, "No sender URL");
    }

    const senderOrigin = new URL(senderUrl).origin;
    if (!this.isAllowedOrigin(senderOrigin)) {
      logger.warn("Message rejected: origin not allowed", { origin: senderOrigin });
      return this.reply(message.requestId, false, "Origin not allowed");
    }

    // 消息路由
    switch (message.type) {
      case "my-browser/ping":
        return await this.ping(message.requestId);

      case "my-browser/switch-to-tab":
        return await this.switchTab(message.sessionId, message.requestId);

      case "my-browser/set-browser-settings":
        return await this.setSettings(message.browserSettings, message.requestId);

      default:
        logger.error("Unsupported message type from Manus App");
        return this.reply("unknown", false, "Unsupported message type");
    }
  }

  async ping(requestId) {
    const settings = BrowserSettings.getBrowserSettings();
    return this.reply(requestId, true, { browserSettings: settings });
  }

  async switchTab(sessionId, requestId) {
    try {
      const tabId = await TabManager.getTabForSession(sessionId);
      await chrome.tabs.update(tabId, { active: true });

      const tab = await chrome.tabs.get(tabId);
      if (tab.windowId) {
        await chrome.windows.update(tab.windowId, { focused: true });
      }

      return this.reply(requestId, true);
    } catch (error) {
      logger.error("Failed to switch tab", { sessionId, error });
      return this.reply(requestId, false, `Failed to switch tab: ${error.message}`);
    }
  }

  reply(requestId, ok, data) {
    return {
      ok,
      source: "my-browser",
      requestId,
      ...(data ? { data } : {}),
      ...(ok ? {} : { error: data })
    };
  }
}
```

---

## 第三阶段：指令下发 (Background → 目标页面)

### 3.1 两种指令下发路径

Background Worker 有两种方式向目标页面下发指令：

#### 路径 A: 通过 Content Script (DOM 操作)

```javascript
// Background Worker
const result = await chrome.tabs.sendMessage(tabId, {
  source: "background",
  type: "automation/click",
  data: {
    target: {
      strategy: "bySelector",
      selector: "button.submit"
    },
    options: {
      scrollIntoView: true
    }
  }
});
```

**适用场景**:
- 点击元素 (`automation/click`)
- 输入文本 (`automation/type`)
- 滚动页面 (`automation/scroll`)
- 检查页面就绪 (`page/check-ready`)

#### 路径 B: 直接通过 CDP (截图、高级操作)

```javascript
// Background Worker
const cdpSession = await CdpClient.getOrCreateSession(tabId);
const result = await cdpSession.send("Page.captureScreenshot", {
  format: "png",
  fromSurface: true,
  clip: { x, y, width, height, scale: 1 }
});
```

**适用场景**:
- 截图 (`Page.captureScreenshot`)
- 获取布局 (`Page.getLayoutMetrics`)
- 执行 JS (`Runtime.evaluate`)

### 3.2 元素定位策略

```javascript
// Content Script 中的元素定位
function resolveTarget(target) {
  switch (target.strategy) {
    case "bySelector":
      // CSS/XPath 选择器
      return document.querySelector(target.selector);

    case "byIndex":
      // 预分配的数字索引
      return document.querySelector(`[data-manus_click_id="${target.index}"]`);

    case "byCoordinates":
      // 视口坐标
      return getElementFromPoint(target.x, target.y);

    default:
      return null;
  }
}
```

**三种定位策略对比**:

| 策略 | 描述 | 精度 | 适用场景 |
|------|------|------|---------|
| `bySelector` | CSS/XPath 选择器 | 高 | 已知元素选择器 |
| `byIndex` | 预分配索引 | 中 | AI 识别后的元素索引 |
| `byCoordinates` | 屏幕坐标 | 低 | 无法用选择器定位 |

---

## 第四阶段：页面执行 (Content Script/CDP)

### 4.1 Content Script 执行 DOM 操作

**文件**: `content.ts.js` (注入到所有网页)

```javascript
// Content Script 消息处理
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  switch (message.type) {
    case "automation/click":
      const result = click(message.data);
      sendResponse(result);
      return true;

    case "automation/type":
      const result = typeText(message.data);
      sendResponse(result);
      return true;

    case "page/check-ready":
      const result = checkReady();
      sendResponse(result);
      return true;

    // ... 更多消息类型
  }
});
```

### 4.2 点击操作实现

```javascript
function click(params) {
  const element = resolveTarget(params.target);

  if (!element || !(element instanceof HTMLElement)) {
    return {
      success: false,
      error: "Target element not found for click action."
    };
  }

  // 滚动到元素
  element.scrollIntoView({
    block: "center",
    inline: "center",
    behavior: "auto"
  });

  // 触发点击事件
  element.dispatchEvent(
    new MouseEvent("click", {
      bubbles: true,
      cancelable: true,
      view: window
    })
  );

  // 蓝色视觉反馈
  showClickEffect(elementRect.x, elementRect.y);

  return {
    success: true,
    message: "Click action executed",
    data: describeElement(element)
  };
}
```

### 4.3 视觉反馈系统

```javascript
// 蓝色点击效果
function showClickEffect(x, y) {
  const size = 36;
  const ripple = document.createElement("div");
  ripple.id = "manus-action-click-effect";
  ripple.style.cssText = `
    position: fixed;
    left: ${x - size / 2}px;
    top: ${y - size / 2}px;
    width: ${size}px;
    height: ${size}px;
    background-color: rgba(0, 129, 242, 0.5);
    border-radius: 50%;
    pointer-events: none;
    z-index: 2147483647;
    animation: manus-action-ripple-effect 1.5s ease-out forwards;
  `;

  document.body.appendChild(ripple);

  ripple.addEventListener("animationend", () => {
    if (ripple.parentNode) {
      ripple.parentNode.removeChild(ripple);
    }
  });
}
```

---

## 第五阶段：结果回传

### 5.1 响应路径

```
Content Script → Background Worker → ManusAppBridge → manus.im (React UI)
```

### 5.2 响应消息格式

```javascript
// 成功响应
{
  ok: true,
  source: "content",  // 或 "background"
  type: "automation/result",
  data: {
    success: true,
    message: "Click action executed",
    // ... 额外数据
  },
  requestId: "..."
}

// 错误响应
{
  ok: false,
  source: "content",
  type: "automation/result",
  error: "Target element not found",
  requestId: "..."
}
```

---

## 完整消息流示例

### 示例：执行点击操作

```
┌──────────────────┐
│   manus.im       │
│   (Web UI)       │
└────────┬─────────┘
         │
         │ ① window.postMessage({
         │     source: "manus-app",
         │     type: "automation/run-scenario",
         │     data: {
         │       scenario: [
         │         { action: "click", selector: "button.submit" }
         │       ]
         │     }
         │   })
         ▼
┌─────────────────────────────────────────────────────────────────────┐
│  ManusAppBridge (Content Script)                                   │
│                                                                     │
│  验证域名 ✓                                                          │
│  验证来源 ✓                                                          │
└───────────────────────────────┬─────────────────────────────────────┘
                                │
                                │ ② chrome.runtime.sendMessage({
                                │     source: "manus-app",
                                │     type: "automation/run-scenario",
                                │     data: { scenario: [...] }
                                │   })
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│  Background Worker                                                  │
│                                                                     │
│  ScenarioRunner.execute(scenario)                                  │
│    │                                                                │
│    ├── page/check-ready (检查页面)                                 │
│    └── automation/click (执行点击)                                  │
└───────────────────────────────┬─────────────────────────────────────┘
                                │
                                │ ③ chrome.tabs.sendMessage(tabId, {
                                │     source: "background",
                                │     type: "automation/click",
                                │     data: { target: { strategy: "bySelector", ... } }
                                │   })
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│  Content Script (目标页面)                                          │
│                                                                     │
│  resolveTarget() → 找到元素                                        │
│  element.scrollIntoView() → 滚动                                    │
│  element.dispatchEvent(click) → 点击                                │
│  showClickEffect() → 蓝色反馈                                       │
└───────────────────────────────┬─────────────────────────────────────┘
                                │
                                │ ④ chrome.runtime.sendMessage({
                                │     source: "content",
                                │     type: "automation/result",
                                │     data: { success: true }
                                │   })
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│  Background Worker → ManusAppBridge → manus.im                     │
│                                                                     │
│  UI 显示操作完成                                                    │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 关键消息类型汇总

### 从 manus.im 发出的消息

| 消息类型 | 触发时机 | 数据 |
|---------|---------|------|
| `session/start` | 开始新任务 | `{ taskName, options }` |
| `session/stop` | 停止任务 | `{ sessionId }` |
| `automation/run-scenario` | 运行自动化场景 | `{ scenario, sessionId }` |
| `my-browser/ping` | 连接检测 | `{ }` |
| `my-browser/switch-to-tab` | 切换标签页 | `{ tabId }` |

### Background 发送到 Content Script 的消息

| 消息类型 | 用途 | 数据结构 |
|---------|------|---------|
| `automation/click` | 点击元素 | `{ target, options }` |
| `automation/type` | 输入文本 | `{ target, text, options }` |
| `automation/scroll` | 滚动页面 | `{ target, direction, amount }` |
| `page/check-ready` | 检查就绪 | `{ }` |
| `page/event-block` | 阻塞事件 | `{ enabled, events }` |

### Content Script 返回的消息

| 消息类型 | 用途 | 数据结构 |
|---------|------|---------|
| `automation/result` | 操作结果 | `{ ok, success, data?, error? }` |
| `automation/progress` | 进度更新 | `{ progress, total }` |
| `page/ready-state` | 页面状态 | `{ ready, reason }` |

---

## CDP 直接调用示例

### 截图操作

```javascript
// Background Worker 中
async function captureScreenshot(tabId) {
  const session = await CdpClient.getOrCreateSession(tabId);

  // 获取布局指标
  const metrics = await session.send("Page.getLayoutMetrics");

  // 计算裁剪区域
  const clip = {
    x: metrics.visualViewport.pageX,
    y: metrics.visualViewport.pageY,
    width: metrics.cssWidth,
    height: metrics.cssHeight,
    scale: 1 / metrics.devicePixelRatio
  };

  // 捕获截图
  const { data } = await session.send("Page.captureScreenshot", {
    format: "png",
    fromSurface: true,
    clip
  });

  return {
    dataUrl: `data:image/png;base64,${data}`,
    width: clip.width,
    height: clip.height
  };
}
```

### JavaScript 执行

```javascript
// Background Worker 中
async function executeScript(tabId, script) {
  const session = await CdpClient.getOrCreateSession(tabId);

  const result = await session.send("Runtime.evaluate", {
    expression: script,
    returnByValue: true,
    awaitPromise: false
  });

  return result.result.value;
}
```

---

## 错误处理机制

### 重试机制

```javascript
// CDP 操作重试
async function executeWithRetry(tabId, handler) {
  const MAX_RETRIES = 2;

  for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
    try {
      const session = await CdpClient.getOrCreateSession(tabId);
      return await handler(session);
    } catch (error) {
      // 清理并重试
      await CdpClient.detachSession(tabId);

      if (attempt > MAX_RETRIES) throw error;

      // 等待后重试
      await sleep(isDebuggingError(error) ? 1000 : 500);
    }
  }
}
```

### 调试器分离检测

```javascript
function isDebuggingError(error) {
  const debuggingErrors = [
    "Debugger is not attached",
    "Target closed",
    "Inspector protocol error",
    "Detached while handling",
    "Cannot access contents of"
  ];

  const errorMsg = error.message?.toLowerCase() || "";
  return debuggingErrors.some(e => errorMsg.includes(e.toLowerCase()));
}
```

---

## 安全考虑

### 1. 域名白名单

```javascript
const ALLOWED_ORIGINS = [
  "https://manus.im",
  "https://vida.butterfly-effect.dev"
];

function isAllowedOrigin(origin) {
  return ALLOWED_ORIGINS.includes(origin) ||
    (Environment.isDev() && isLocalhost(origin));
}
```

### 2. 类型守卫

```javascript
// 验证消息来源
if (!isManusAppMessage(message)) {
  throw new Error("Invalid message source");
}

// 验证消息类型
function isSessionStartMessage(message) {
  return isManusAppMessage(message) &&
         message.type === "session/start";
}
```

### 3. Content Script 隔离

- Content Script 无法直接访问 `manus_extension_token`
- 所有敏感操作需经过 Background Worker
- Background Worker 验证每个请求的来源

---

## 性能优化

### 1. CDP 会话缓存

```javascript
// CDP 会话缓存 60 秒
const CDP_SESSION_TIMEOUT = 60000;
const cdpSessions = new Map(); // tabId -> session

async function getOrCreateSession(tabId) {
  let session = cdpSessions.get(tabId);

  if (session) {
    session.lastUsed = Date.now();
    return session;
  }

  // 创建新会话
  session = await attachDebugger(tabId);
  cdpSessions.set(tabId, session);

  // 60 秒不活跃后自动分离
  setTimeout(() => {
    if (Date.now() - session.lastUsed > CDP_SESSION_TIMEOUT) {
      detachDebugger(tabId);
      cdpSessions.delete(tabId);
    }
  }, CDP_SESSION_TIMEOUT);

  return session;
}
```

### 2. 操作队列

```javascript
// 每个会话有操作队列，确保顺序执行
class SessionManager {
  startSession(sessionId) {
    this.sessions.set(sessionId, {
      queue: Promise.resolve(),
      // ...
    });
  }

  async enqueueOperation(sessionId, operation) {
    const session = this.sessions.get(sessionId);
    session.queue = session.queue.then(operation);
    return session.queue;
  }
}
```

---

## 附录：完整配置示例

### 环境配置

```javascript
// sendMessage.js
const ENV_CONFIG = {
  prod: {
    socketEndpoint: "wss://api.manus.im",
    webAppDomain: "https://manus.im",
    onboardingUrl: "https://manus.im/my-browser"
  },
  dev: {
    socketEndpoint: "wss://vida.butterfly-effect.dev",
    webAppDomain: "https://manus.im"
  },
  local: {
    socketEndpoint: "http://localhost:4000",
    webAppDomain: "https://vida.butterfly-effect.dev"
  }
};
```

### CDP 配置

```javascript
// background.ts.js
const CDP_VERSION = "1.3";
const SESSION_TIMEOUT = 60000;  // 60 秒
const MAX_RETRIES = 2;
const DEFAULT_WIDTH = 1920;
const DEFAULT_HEIGHT = 1080;
```

---

**文档创建时间**: 2026-01-28
**版本**: 1.0
**相关文档**:
- [sidepanel实现方式发现报告.md](../09_重要发现/sidepanel实现方式发现报告.md)
- [消息类型分类.md](../00_概述/消息类型分类.md)
- [架构分析.md](../02_后台工作器/架构分析.md)
