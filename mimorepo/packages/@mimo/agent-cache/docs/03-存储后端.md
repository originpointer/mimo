# 存储后端配置

## 概述

`@mimo/agent-cache` 提供了统一的存储接口 `ICacheStore`，支持多种存储后端。

## MemoryStore (内存存储)

### 特性

- **同步操作**：所有操作都是同步的，速度最快
- **LRU 淘汰**：支持最大条目数限制
- **自动清理**：支持定期清理过期条目
- **零依赖**：不需要文件系统权限

### 创建 MemoryStore

```typescript
import { MemoryStore } from '@mimo/agent-cache/storage';

const store = new MemoryStore({
    maxSize: 1000,              // 最大条目数
    defaultTTL: 3600000,         // 默认 TTL (1小时)
    cleanupInterval: 300000,     // 清理间隔 (5分钟)
});
```

### 配置选项

```typescript
interface MemoryStoreOptions {
    maxSize?: number;           // 最大条目数，超过后自动淘汰最旧的
    defaultTTL?: number;         // 默认 TTL (毫秒)
    cleanupInterval?: number;    // 定期清理过期条目的间隔 (毫秒)，0 禁用
}
```

### 使用示例

```typescript
// 基础使用
store.set('key1', { data: 'value1' }, 60000);  // 1分钟 TTL
const value = store.get('key1');               // { data: 'value1' }
store.delete('key1');

// 统计
const stats = store.getStats();
console.log(stats);
// {
//     totalEntries: 10,
//     memoryUsage: 2048,
//     hitRate: 0.75,
//     ...
// }

// 清理过期条目
store.cleanupExpired();

// 清空所有
store.clear();
```

### 序列化

```typescript
// 保存状态
const data = store.save();
await fs.writeFile('memory-cache.json', JSON.stringify(data));

// 恢复状态
const saved = JSON.parse(await fs.readFile('memory-cache.json', 'utf-8'));
store.load(saved);
```

### 销毁存储

```typescript
// 清理定时器和数据
store.destroy();
```

## FileSystemStore (文件系统存储)

### 特性

- **持久化**：数据持久化到磁盘
- **异步操作**：所有操作都是异步的
- **索引管理**：内存索引加速查询
- **崩溃恢复**：支持从索引恢复

### 创建 FileSystemStore

```typescript
import { FileSystemStore } from '@mimo/agent-cache/storage';

const store = new FileSystemStore({
    rootDir: './cache',      // 根目录
    subdir: 'agent',         // 子目录
    defaultTTL: 86400000,    // 默认 24小时
});
```

### 配置选项

```typescript
interface FileSystemStoreOptions {
    rootDir: string;         // 缓存根目录 (必需)
    subdir?: string;         // 子目录 (可选)
    defaultTTL?: number;     // 默认 TTL (毫秒)
}
```

### 使用示例

```typescript
// 所有操作都是异步的
await store.set('key1', { data: 'value1' });
const value = await store.get('key1');
await store.delete('key1');

// 统计
const stats = await store.getStats();

// 获取所有键
const keys = await store.keys();

// 检查键是否存在
const exists = await store.has('key1');
```

### 文件结构

```
./cache/
├── .index.json           # 索引文件
├── agent/                # 子目录
│   ├── abc123.json
│   └── def456.json
└── token/                # 另一个子目录
    ├── ghi789.json
    └── jkl012.json
```

### 索引文件格式

```json
{
  "keyToPath": {
    "agent:agent:abc123": "./cache/agent/abc123.json",
    "token:token:def456": "./cache/token/def456.json"
  },
  "metadata": {
    "agent:agent:abc123": {
      "createdAt": 1735737600000,
      "expiresAt": 1735824000000,
      "size": 1024,
      "hits": 5
    }
  }
}
```

## 在 CacheManager 中使用

### 使用 MemoryStore

```typescript
import { CacheManager } from '@mimo/agent-cache';
import { MemoryStore } from '@mimo/agent-cache/storage';

const cache = CacheManager.create(
    { namespace: 'my-app' },
    {
        tokenStore: new MemoryStore({ maxSize: 500 }),
        agentStore: new MemoryStore({ maxSize: 100 }),
    }
);
```

### 使用 FileSystemStore

```typescript
import { CacheManager } from '@mimo/agent-cache';
import { FileSystemStore } from '@mimo/agent-cache/storage';

const cache = CacheManager.create(
    { namespace: 'my-app' },
    {
        tokenStore: new FileSystemStore({
            rootDir: './cache',
            subdir: 'token',
        }),
        agentStore: new FileSystemStore({
            rootDir: './cache',
            subdir: 'agent',
        }),
    }
);
```

### 混合使用

```typescript
const cache = CacheManager.create(
    { namespace: 'my-app' },
    {
        // Token 追踪使用文件系统 (持久化)
        tokenStore: new FileSystemStore({
            rootDir: './cache',
            subdir: 'token',
        }),
        // Agent 缓存使用内存 (快速访问)
        agentStore: new MemoryStore({
            maxSize: 100,
            defaultTTL: 3600000,
        }),
    }
);
```

## 自定义存储后端

### 实现 ICacheStore

```typescript
import type { ICacheStore, CacheStoreType, CacheStats } from '@mimo/agent-cache';
import { BaseCacheStore } from '@mimo/agent-cache/core';

class RedisStore extends BaseCacheStore implements ICacheStore {
    readonly type: CacheStoreType = 'redis';
    private client: RedisClient;

    constructor(redisClient: RedisClient, defaultTTL?: number) {
        super(defaultTTL);
        this.client = redisClient;
    }

    async get<T>(key: string): Promise<T | null> {
        const data = await this.client.get(key);
        return data ? JSON.parse(data) : null;
    }

    async set<T>(key: string, value: T, ttl?: number): Promise<void> {
        const data = JSON.stringify(value);
        if (ttl) {
            await this.client.setex(key, ttl / 1000, data);
        } else {
            await this.client.set(key, data);
        }
    }

    async delete(key: string): Promise<boolean> {
        const result = await this.client.del(key);
        return result > 0;
    }

    async clear(): Promise<void> {
        await this.client.flushDb();
    }

    async has(key: string): Promise<boolean> {
        const result = await this.client.exists(key);
        return result > 0;
    }

    async keys(): Promise<string[]> {
        return await this.client.keys('*');
    }

    async getStats(): Promise<CacheStats> {
        const info = await this.client.info('stats');
        // 解析 Redis info 并返回 CacheStats
        return {
            totalEntries: parseInt(info.keyspace),
            memoryUsage: parseInt(info.used_memory),
            hitRate: parseFloat(info.hit_rate),
            totalRequests: 0,
            hits: 0,
            misses: 0,
        };
    }
}
```

### 使用自定义存储

```typescript
import { CacheManager } from '@mimo/agent-cache';
import { RedisStore } from './RedisStore';

const redis = new Redis();
const cache = CacheManager.create(
    { namespace: 'my-app' },
    {
        tokenStore: new RedisStore(redis),
        agentStore: new RedisStore(redis),
    }
);
```

## 存储后端选择指南

| 场景 | 推荐存储 | 原因 |
|------|----------|------|
| 开发/测试 | MemoryStore | 最快速度，无需持久化 |
| 生产环境 (单实例) | FileSystemStore | 数据持久化，崩溃恢复 |
| 生产环境 (分布式) | RedisStore | 多实例共享缓存 |
| 高性能要求 | MemoryStore | 最快访问速度 |
| 大数据量 | FileSystemStore | 不受内存限制 |

## 性能对比

| 操作 | MemoryStore | FileSystemStore | RedisStore |
|------|-------------|------------------|------------|
| get | ~0.001ms | ~1-5ms | ~0.5-2ms |
| set | ~0.002ms | ~2-10ms | ~0.5-2ms |
| delete | ~0.001ms | ~1-5ms | ~0.5-2ms |
| keys | ~0.1ms | ~1-2ms | ~5-20ms |

## 同步/异步统一

由于 `ICacheStore` 接口支持 `SyncOrAsync`，可以编写与存储后端无关的代码：

```typescript
async function getValue<T>(store: ICacheStore, key: string): Promise<T | null> {
    // MemoryStore 返回同步结果，FileSystemStore 返回 Promise
    // 使用 await 自动处理两种情况
    return await store.get<T>(key);
}

// 这个函数对任何存储后端都有效
const fromMemory = await getValue(memoryStore, 'key');
const fromDisk = await getValue(fileStore, 'key');
```
