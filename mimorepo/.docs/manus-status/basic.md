根据 `content.ts.js` 的源码架构及我们之前的对话历史，Manus 扩展的核心逻辑依赖于一个严谨的**四态状态机**。这个状态机不仅管理 UI 呈现，还决定了输入事件的拦截策略和任务执行流。

以下是关于该状态机的详细定义、实现编码细节及转换逻辑：

### 1. 状态机定义 (State Definitions)

Manus 的 Content Script 定义了 4 种互斥状态，每种状态对应特定的 UI 表现和交互权限：

#### **(1) Idle (空闲态)**
*   **定义**：扩展已加载但无任务执行的默认状态。
*   **特征**：
    *   **UI**：无任何注入元素，页面保持原样。
    *   **权限**：用户拥有对页面的完全控制权。

#### **(2) Hidden (隐藏态)**
*   **定义**：任务存在但处于后台运行或暂停显示模式。
*   **特征**：
    *   **UI**：隐藏所有覆盖层，无视觉干扰。
    *   **逻辑**：任务上下文保留，但暂停向用户展示前端反馈。

#### **(3) Ongoing (进行态 - 核心状态)**
*   **定义**：自动化任务正在活跃执行中。
*   **特征**：
    *   **视觉安全锁**：强制渲染**蓝色渐变边框**和内阴影遮罩。这是关键的安全设计，明确告知用户“AI 接管中”,。
    *   **状态栏**：底部显示当前步骤状态及“停止”按钮。
    *   **标题反馈**：Tab 标题会动态显示 Emoji（如 👆 指示点击，🖐️ 指示等待）。
    *   **事件拦截**：默认拦截用户的鼠标和键盘事件，防止误操作干扰 AI。

#### **(4) Takeover (接管态)**
*   **定义**：用户强行介入中断了 AI 操作。
*   **特征**：
    *   **触发**：检测到用户移动鼠标、点击或按键。
    *   **UI 变更**：显示“恢复任务”或“停止任务”的显式按钮。
    *   **权限释放**：解除事件拦截，允许用户自由操作页面。

---

### 2. 实现此状态机的编码细节 (Implementation Details)

在代码实现层面，为了保证状态机的稳定性和用户体验，需要注意以下关键技术点：

#### **A. 最早注入原则 (Injection Timing)**
*   **细节**：Content Script 必须配置为在 `document_start` 时机注入。
*   **原因**：必须在页面 DOM 尚未完全加载前初始化状态机，以防止页面脚本在扩展接管前抢占事件监听器，确保状态机能捕获页面生命周期初期的所有事件。

#### **B. 视觉反馈的强制性 (Security UI)**
*   **细节**：在 `Ongoing` 状态下，蓝色遮罩的渲染应具有最高层级（z-index）。
*   **原因**：这不仅是 UI，更是安全机制。必须确保用户时刻知晓当前浏览器不受自己控制，避免 AI 操作被误认为是恶意劫持。

#### **C. "隐形焦点"的兼容处理 (Background Handling)**
*   **细节**：状态机必须能处理“页面不可见但任务进行中”的悖论。
*   **挑战**：当 Manus 在后台标签页工作时，页面 `visibilityState` 为 `hidden`，但通过 `window.focus()` 和 CDP 使得 `document.hasFocus()` 为 `true`。
*   **编码注意**：状态判断逻辑不能单纯依赖 `visibilityState`。即使页面隐藏，只要收到任务指令，内部状态仍需切换为 `Ongoing`，但可能需要根据可见性优化渲染开销（例如在后台时不渲染高消耗的 CSS 动画）。

#### **D. 事件监听与拦截 (Event Interception)**
*   **细节**：在 `Ongoing` 状态下，需要使用 `capture: true`（捕获阶段）添加事件监听器，并调用 `stopPropagation()` 和 `preventDefault()` 阻止用户事件冒泡，但在 `Takeover` 状态下必须立即解绑或透传这些事件,。

---

### 3. 状态转换逻辑 (Transition Logic)

状态转换由**后台指令（指令驱动）**和**用户行为（事件驱动）**共同触发：

#### **流程 1: 启动任务 (Idle $\rightarrow$ Ongoing)**
*   **触发**：收到 Background 发送的 `session/start` 或 `automation/activate` 消息。
*   **动作**：
    1.  初始化 Session 上下文。
    2.  注入蓝色遮罩 DOM 和状态栏组件。
    3.  挂载全局事件拦截器（Blockers）。

#### **流程 2: 用户介入 (Ongoing $\rightarrow$ Takeover)**
*   **触发**：
    *   **被动触发**：捕获到 `mousemove`, `mousedown`, `keydown` 等用户原生事件。
    *   **主动触发**：收到 `extension/unauthorize-task` 消息。
*   **动作**：
    1.  发送信号暂停自动化队列。
    2.  移除事件拦截器。
    3.  更新 UI，显示“恢复”按钮。

#### **流程 3: 恢复任务 (Takeover $\rightarrow$ Ongoing)**
*   **触发**：用户点击状态栏的“恢复”按钮（发送 `extension/resume-task`）。
*   **动作**：
    1.  重新挂载事件拦截器。
    2.  恢复蓝色遮罩显示。
    3.  通知后台继续执行指令队列。

#### **流程 4: 终止任务 (Any $\rightarrow$ Idle)**
*   **触发**：
    *   任务自然完成（Emoji 变 ✅）。
    *   用户点击“停止”按钮（发送 `extension/stop-task`）。
    *   后台强制结束（发送 `session/stop`）。
*   **动作**：
    1.  **清理（Cleanup）**：移除所有注入的 DOM 节点（遮罩、状态栏）。
    2.  **重置**：销毁所有监听器，释放内存，恢复页面原始交互能力。