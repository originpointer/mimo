# Stagehand DOM 序列化 - 架构概述

## 1. 功能目标

将浏览器页面的 DOM 结构序列化为 LLM 可理解的格式，同时建立元素标识符（elementId）到选择器（XPath）的映射，使 LLM 能够：

1. **理解页面结构**：通过文本大纲（combinedTree）了解页面的语义化结构
2. **定位目标元素**：通过返回 elementId，服务端可查找对应的 XPath 进行操作
3. **提取 URL 信息**：自动收集页面中的链接地址

## 2. 核心概念

### 2.1 Hybrid Snapshot

"Hybrid" 指同时使用 **DOM 树** 和 **可访问性树（AX Tree）** 的组合表示：

| 数据源 | 提供的信息 | 用途 |
|--------|-----------|------|
| DOM 树 | HTML 结构、属性、XPath | 元素定位 |
| AX 树 | 语义角色、名称、状态 | LLM 理解 |

### 2.2 输出格式

```typescript
interface HybridSnapshot {
  // 文本大纲（供 LLM 使用）
  combinedTree: string
  
  // elementId → XPath 映射（用于元素定位）
  combinedXpathMap: Record<string, string>
  
  // elementId → URL 映射（用于链接提取）
  combinedUrlMap: Record<string, string>
}
```

### 2.3 ElementId 编码

ElementId 格式：`{frameOrdinal}-{backendNodeId}`

- `frameOrdinal`：Frame 序号（主 frame 为 0）
- `backendNodeId`：CDP 分配的节点后端 ID

示例：`0-29` 表示主 frame 中 backendNodeId 为 29 的节点

## 3. 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                    POST /control/snapshot                    │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   captureHybridSnapshot                      │
│  ┌─────────────┐  ┌──────────────┐  ┌───────────────────┐  │
│  │ buildFrame  │  │ collectPer   │  │ mergeFramesInto   │  │
│  │ Context     │→ │ FrameMaps    │→ │ Snapshot          │  │
│  └─────────────┘  └──────────────┘  └───────────────────┘  │
└─────────────────────────────────────────────────────────────┘
           │                │                    │
           ▼                ▼                    ▼
┌────────────────┐ ┌────────────────┐ ┌────────────────────┐
│ Page.getFrame  │ │ DOM.getDocument│ │ Accessibility.get  │
│ Tree           │ │ DOM.describeNode│ │ FullAXTree        │
└────────────────┘ └────────────────┘ └────────────────────┘
           │                │                    │
           └────────────────┴────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                      DriverAdapter                           │
│              (CDP 命令发送到 Chrome Extension)               │
└─────────────────────────────────────────────────────────────┘
```

## 4. 模块职责

### 4.1 capture.ts - 主入口

- `captureHybridSnapshot()` - 完整的多 Frame 快照
- `captureSimpleSnapshot()` - 简化的单 Frame 快照
- `buildFrameContext()` - 构建 Frame 树上下文
- `computeFramePrefixes()` - 计算 iframe XPath 前缀
- `mergeFramesIntoSnapshot()` - 合并多 Frame 数据

### 4.2 domTree.ts - DOM 处理

- `getDomTreeWithFallback()` - 带回退的 DOM 获取
- `hydrateDomTree()` - DOM 树水合（填充截断的节点）
- `domMapsForSession()` - 生成 DOM 映射
- `buildSessionDomIndex()` - 构建 Session 级别的 DOM 索引

### 4.3 a11yTree.ts - 可访问性树处理

- `a11yForFrame()` - 获取 Frame 的 AX 树
- `decorateRoles()` - 装饰角色信息
- `buildHierarchicalTree()` - 构建层级树结构

### 4.4 xpathUtils.ts - XPath 工具

- `normalizeXPath()` - 标准化 XPath
- `prefixXPath()` - 添加 iframe 前缀
- `buildChildXPathSegments()` - 构建子节点 XPath 段
- `relativizeXPath()` - 相对化 XPath

### 4.5 treeFormatUtils.ts - 格式化工具

- `formatTreeLine()` - 格式化树节点为文本行
- `injectSubtrees()` - 注入子 Frame 大纲
- `cleanText()` - 清理文本中的不可见字符

## 5. 数据流

```
1. 获取 Frame 树结构
   Page.getFrameTree → FrameContext { rootId, parentByFrame, frames }

2. 构建 DOM 索引
   DOM.getDocument → DOM.describeNode（水合）→ SessionDomIndex

3. 生成 DOM 映射
   SessionDomIndex → { tagNameMap, xpathMap, scrollableMap }

4. 获取可访问性树
   Accessibility.getFullAXTree → decorateRoles → buildHierarchicalTree → outline

5. 计算 Frame 前缀
   DOM.getFrameOwner → iframe XPath → absPrefix

6. 合并快照
   perFrameMaps + perFrameOutlines → HybridSnapshot
```

## 6. 使用流程

### 6.1 LLM 交互流程

```
1. 调用 POST /control/snapshot 获取快照
   ↓
2. 将 combinedTree 发送给 LLM
   ↓
3. LLM 分析页面结构，返回目标 elementId
   ↓
4. 服务端通过 combinedXpathMap[elementId] 获取 XPath
   ↓
5. 使用 XPath 定位元素并执行操作
```

### 6.2 示例

**输入**：LLM 收到的 combinedTree
```
[0-16] RootWebArea: Stagehand Test Page
  [0-17] scrollable, html
    [0-23] body
      [0-29] button: Click Me
      [0-5] textbox: Type here
```

**LLM 输出**：
```json
{
  "elementId": "0-29",
  "action": "click",
  "description": "点击 Click Me 按钮"
}
```

**服务端处理**：
```typescript
const xpath = combinedXpathMap["0-29"]  // "/html[1]/body[1]/button[1]"
await driver.clickSelector(xpath)
```

## 7. 与 Stagehand 原版的差异

| 方面 | Stagehand 原版 | 当前实现 |
|------|---------------|---------|
| 运行环境 | Puppeteer 进程内 | Chrome Extension + Server |
| CDP 调用 | 直接调用 | 通过 DriverAdapter 中转 |
| Session 管理 | 内置 | sessionRegistry + SSE |
| focusSelector | 完整实现 | 基础支持（TODO） |
| 缓存机制 | ActCache | 未实现 |
