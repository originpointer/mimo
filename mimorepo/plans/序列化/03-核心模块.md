# Stagehand DOM 序列化 - 核心模块

## 模块概览

```
.refer/server/utils/control/snapshot/
├── index.ts              # 模块导出
├── capture.ts            # 主入口，完整快照捕获
├── domTree.ts            # DOM 树处理
├── a11yTree.ts           # 可访问性树处理
├── xpathUtils.ts         # XPath 工具函数
└── treeFormatUtils.ts    # 树格式化工具
```

---

## 1. capture.ts - 主入口模块

**位置**: `.refer/server/utils/control/snapshot/capture.ts`

### 1.1 captureHybridSnapshot

完整的多 Frame 快照捕获函数。

```typescript
export async function captureHybridSnapshot(
  driver: DriverAdapter,
  options?: SnapshotOptions & { sessionId?: string; tabId?: number }
): Promise<HybridSnapshot>
```

**执行流程**：

```
1. buildFrameContext()      → 获取 frame 树结构
2. buildSessionIndexes()    → 构建 session 级 DOM 索引
3. collectPerFrameMaps()    → 收集每个 frame 的映射
4. computeFramePrefixes()   → 计算 iframe XPath 前缀
5. mergeFramesIntoSnapshot() → 合并所有数据
```

**核心代码**：

```typescript
export async function captureHybridSnapshot(
  driver: DriverAdapter,
  options?: SnapshotOptions & { sessionId?: string; tabId?: number }
): Promise<HybridSnapshot> {
  const pierce = options?.pierceShadow ?? true

  // 1. 获取 frame 上下文
  const context = await buildFrameContext(driver, { tabId })

  // 2. 为每个 session 构建 DOM 索引
  const sessionToIndex = await buildSessionIndexes(driver, context, pierce, { sessionId, tabId })

  // 3. 收集每个 frame 的映射和大纲
  const { perFrameMaps, perFrameOutlines } = await collectPerFrameMaps(
    driver, context, sessionToIndex, options, pierce, { sessionId, tabId }
  )

  // 4. 计算 iframe 前缀
  const { absPrefix, iframeHostEncByChild } = await computeFramePrefixes(
    driver, context, perFrameMaps, { sessionId, tabId }
  )

  // 5. 合并所有 frame 数据
  return mergeFramesIntoSnapshot(
    context, perFrameMaps, perFrameOutlines, absPrefix, iframeHostEncByChild
  )
}
```

### 1.2 buildFrameContext

构建 frame 树上下文。

```typescript
export async function buildFrameContext(
  driver: DriverAdapter,
  options?: { tabId?: number }
): Promise<FrameContext>
```

**返回值**：

```typescript
interface FrameContext {
  rootId: string                           // 根 frame ID
  parentByFrame: Map<string, string | null> // frameId → parentId
  frames: string[]                          // 所有 frame ID 列表
}
```

**实现**：通过 `Page.getFrameTree` CDP 命令获取 frame 树，递归索引所有 frame。

### 1.3 collectPerFrameMaps

收集每个 frame 的 DOM 映射和可访问性大纲。

```typescript
export async function collectPerFrameMaps(
  driver: DriverAdapter,
  context: FrameContext,
  sessionToIndex: Map<string, SessionDomIndex>,
  options: SnapshotOptions | undefined,
  pierce: boolean,
  driverOptions?: { sessionId?: string; tabId?: number }
): Promise<{
  perFrameMaps: Map<string, FrameDomMaps>
  perFrameOutlines: Array<{ frameId: string; outline: string }>
}>
```

**关键逻辑**：

1. 为每个 frame 分配序号（ordinal）
2. 确定文档根（主 frame 或 iframe 的 contentDocument）
3. 生成编码函数：`encode = (be) => "${ordinal}-${be}"`
4. 从 DOM 索引提取映射
5. 获取可访问性树并生成大纲

### 1.4 computeFramePrefixes

计算每个 frame 的绝对 XPath 前缀。

```typescript
export async function computeFramePrefixes(
  driver: DriverAdapter,
  context: FrameContext,
  perFrameMaps: Map<string, FrameDomMaps>,
  options?: { sessionId?: string; tabId?: number }
): Promise<{
  absPrefix: Map<string, string>
  iframeHostEncByChild: Map<string, string>
}>
```

**工作原理**：

1. 根 frame 前缀为空 `""`
2. BFS 遍历 frame 树
3. 对每个子 frame，通过 `DOM.getFrameOwner` 获取宿主 iframe 元素
4. 从父 frame 的 xpathMap 中获取 iframe 的 XPath
5. 计算子 frame 的绝对前缀 = 父前缀 + iframe XPath

### 1.5 mergeFramesIntoSnapshot

合并所有 frame 数据为最终快照。

```typescript
export function mergeFramesIntoSnapshot(
  context: FrameContext,
  perFrameMaps: Map<string, FrameDomMaps>,
  perFrameOutlines: Array<{ frameId: string; outline: string }>,
  absPrefix: Map<string, string>,
  iframeHostEncByChild: Map<string, string>
): HybridSnapshot
```

**合并策略**：

1. 根 frame 的映射直接复制
2. 子 frame 的 XPath 添加前缀后合并
3. 使用 `injectSubtrees` 将子 frame 大纲注入到父 frame 的 iframe 节点下

---

## 2. domTree.ts - DOM 树处理模块

**位置**: `.refer/server/utils/control/snapshot/domTree.ts`

### 2.1 getDomTreeWithFallback

带回退策略的 DOM 树获取。

```typescript
export async function getDomTreeWithFallback(
  driver: DriverAdapter,
  pierce: boolean,
  options?: { sessionId?: string; tabId?: number }
): Promise<DomNode>
```

**回退策略**：

```typescript
const DOM_DEPTH_ATTEMPTS = [-1, 256, 128, 64, 32, 16, 8, 4, 2, 1]
```

当遇到 CBOR 栈溢出错误时，逐步减小 depth 参数重试。

### 2.2 hydrateDomTree

DOM 树水合（填充截断的节点）。

```typescript
export async function hydrateDomTree(
  driver: DriverAdapter,
  root: DomNode,
  pierce: boolean,
  options?: { sessionId?: string; tabId?: number }
): Promise<void>
```

**工作流程**：

1. 使用栈进行深度优先遍历
2. 检查每个节点是否被截断（`childNodeCount > children.length`）
3. 对截断节点调用 `DOM.describeNode` 获取完整子树
4. 同样使用深度回退策略避免 CBOR 错误

### 2.3 buildSessionDomIndex

构建 session 级别的 DOM 索引。

```typescript
export async function buildSessionDomIndex(
  driver: DriverAdapter,
  pierce: boolean,
  options?: { sessionId?: string; tabId?: number }
): Promise<SessionDomIndex>
```

**索引内容**：

| 字段 | 类型 | 说明 |
|------|------|------|
| `rootBackend` | `number` | 根节点 backendNodeId |
| `absByBe` | `Map<number, string>` | backendNodeId → 绝对 XPath |
| `tagByBe` | `Map<number, string>` | backendNodeId → 标签名 |
| `scrollByBe` | `Map<number, boolean>` | backendNodeId → 可滚动 |
| `docRootOf` | `Map<number, number>` | backendNodeId → 所属文档根 |
| `contentDocRootByIframe` | `Map<number, number>` | iframe → contentDocument 根 |

### 2.4 extractDomMapsFromIndex

从索引中提取指定文档根的 DOM 映射。

```typescript
export function extractDomMapsFromIndex(
  index: SessionDomIndex,
  docRootBe: number,
  encode: (backendNodeId: number) => string
): DomMaps
```

**转换过程**：

1. 过滤出属于指定文档根的节点
2. 将绝对 XPath 转换为相对路径
3. 使用 encode 函数生成 encodedId

---

## 3. a11yTree.ts - 可访问性树处理模块

**位置**: `.refer/server/utils/control/snapshot/a11yTree.ts`

### 3.1 a11yForFrame

获取 frame 的可访问性树并生成文本大纲。

```typescript
export async function a11yForFrame(
  driver: DriverAdapter,
  frameId: string | undefined,
  opts: A11yOptions,
  options?: { sessionId?: string; tabId?: number }
): Promise<AccessibilityTreeResult>
```

**执行流程**：

```
1. Accessibility.getFullAXTree   → 获取 AX 节点列表
2. decorateRoles()               → 装饰角色信息
3. buildHierarchicalTree()       → 构建层级结构
4. formatTreeLine()              → 生成文本大纲
```

### 3.2 decorateRoles

装饰 AX 节点的角色信息。

```typescript
export function decorateRoles(
  nodes: AXNode[],
  opts: A11yOptions
): A11yNodeInternal[]
```

**处理逻辑**：

1. 为每个节点生成 `encodedId`
2. 处理可滚动元素，添加 `scrollable` 前缀
3. 提取 role、name、description 等属性

### 3.3 buildHierarchicalTree

构建层级树结构。

```typescript
export function buildHierarchicalTree(
  nodes: A11yNodeInternal[],
  opts: A11yOptions
): { tree: A11yNodeInternal[] }
```

**过滤规则**：

1. 保留有 name 的节点
2. 保留有子节点的节点
3. 保留非结构性角色（排除 generic、none、inlinetextbox）

### 3.4 isStructural

判断角色是否为纯结构性。

```typescript
export function isStructural(role: string): boolean {
  const r = role?.toLowerCase()
  return r === "generic" || r === "none" || r === "inlinetextbox"
}
```

这些节点在最终输出中会被省略或提升子节点。

---

## 4. xpathUtils.ts - XPath 工具模块

**位置**: `.refer/server/utils/control/snapshot/xpathUtils.ts`

### 4.1 normalizeXPath

标准化 XPath 表达式。

```typescript
export function normalizeXPath(x?: string): string
```

**处理**：
- 去除 `xpath=` 前缀
- 确保以 `/` 开头
- 去除尾部 `/`

### 4.2 prefixXPath

为 XPath 添加前缀。

```typescript
export function prefixXPath(parentAbs: string, child: string): string
```

**示例**：

```typescript
prefixXPath("/html[1]/body[1]/iframe[1]", "/html[1]/div[1]")
// → "/html[1]/body[1]/iframe[1]/html[1]/div[1]"
```

### 4.3 buildChildXPathSegments

构建子节点的 XPath 段。

```typescript
export function buildChildXPathSegments(kids: DomNode[]): string[]
```

**输出示例**：

```typescript
// 输入：[<div>, <span>, <div>, #text]
// 输出：["div[1]", "span[1]", "div[2]", "text()[1]"]
```

### 4.4 relativizeXPath

将绝对 XPath 相对化。

```typescript
export function relativizeXPath(baseAbs: string, nodeAbs: string): string
```

**示例**：

```typescript
relativizeXPath("/html[1]/body[1]", "/html[1]/body[1]/div[1]")
// → "/div[1]"
```

---

## 5. treeFormatUtils.ts - 树格式化工具

**位置**: `.refer/server/utils/control/snapshot/treeFormatUtils.ts`

### 5.1 formatTreeLine

格式化单个树节点为文本行。

```typescript
export function formatTreeLine(node: A11yNodeInternal, level = 0): string
```

**输出格式**：

```
[encodedId] role: name
  [childId] childRole: childName
```

### 5.2 injectSubtrees

将子 frame 大纲注入父 frame。

```typescript
export function injectSubtrees(
  rootOutline: string,
  idToTree: Map<string, string>
): string
```

**工作原理**：

1. 遍历根大纲的每一行
2. 匹配行中的 encodedId
3. 如果该 encodedId 对应 iframe，将子 frame 大纲作为其子节点注入
4. 递归处理嵌套 iframe

### 5.3 cleanText

清理文本中的不可见字符。

```typescript
export function cleanText(input: string): string
```

**处理**：
- 移除 Unicode 私有使用区字符 (U+E000-U+F8FF)
- 将各种空格变体规范化
- 折叠连续空白

---

## 6. driverAdapter.ts 新增方法

**位置**: `.refer/server/utils/control/driverAdapter.ts`

### 6.1 describeNode

获取节点详细信息（用于水合）。

```typescript
async describeNode(options: {
  nodeId?: number
  backendNodeId?: number
  depth?: number
  pierce?: boolean
  sessionId?: string
  tabId?: number
}): Promise<DomNode>
```

### 6.2 getFrameOwner

获取 frame 的宿主元素。

```typescript
async getFrameOwner(
  frameId: string,
  options?: { sessionId?: string; tabId?: number }
): Promise<{ backendNodeId?: number; nodeId?: number }>
```

### 6.3 getFullAXTree

获取完整的可访问性树。

```typescript
async getFullAXTree(options?: {
  frameId?: string
  sessionId?: string
  tabId?: number
}): Promise<AXNode[]>
```

### 6.4 enableAccessibility / enableDOM / enableRuntime

启用相关 CDP 域。

```typescript
async enableAccessibility(options?: { sessionId?: string; tabId?: number }): Promise<void>
async enableDOM(options?: { sessionId?: string; tabId?: number }): Promise<void>
async enableRuntime(options?: { sessionId?: string; tabId?: number }): Promise<void>
```

---

## 7. 模块依赖关系

```
capture.ts
├── domTree.ts
│   └── xpathUtils.ts
├── a11yTree.ts
│   └── treeFormatUtils.ts
└── xpathUtils.ts

API 调用链：
snapshot.post.ts → captureHybridSnapshot() → DriverAdapter → Chrome Extension → CDP
```
