# OpenCode 计划制定流程

## 概述

OpenCode 的计划模式（Plan Mode）是一个只读分析阶段，允许 AI 在执行代码更改之前先探索代码库、理解需求，并制定详细的实施计划。这有助于确保复杂的任务得到周密的规划，减少错误和返工。

## 计划模式触发

### 1. 通过 Plan Agent

```bash
# 用户选择 plan agent
POST /session/:sessionID/message
{
  "agent": "plan",
  "parts": [
    { "type": "text", "text": "帮我添加用户认证功能" }
  ]
}
```

### 2. 计划模式权限配置

**位置**: `packages/opencode/src/agent/agent.ts`

```typescript
plan: {
  name: "plan",
  permission: PermissionNext.merge(
    defaults,
    PermissionNext.fromConfig({
      question: "allow",         // 允许向用户提问
      plan_exit: "allow",        // 允许退出计划模式
      edit: {
        "*": "deny",             // 禁止编辑任何文件
        ".opencode/plans/*.md": "allow",  // 只能编辑计划文件
      },
    }),
    user,
  ),
  mode: "primary",
  native: true,
}
```

## 计划模式提示词

### 系统提醒

**位置**: `packages/opencode/src/session/prompt/plan-reminder-anthropic.txt`

```
<system-reminder>
# Plan Mode - System Reminder

Plan mode is active. The user indicated that they do not want you
to execute yet -- you MUST NOT make any edits (with the exception of
the plan file mentioned below), run any non-readonly tools, or otherwise
make any changes to the system.

---

## Plan File Info

No plan file exists yet. You should create your plan at:
`/Users/user/.claude/plans/{slug}.md` using the Write tool.

You should build your plan incrementally by writing to or editing
this file. NOTE that this is the only file you are allowed to edit.

---

## Enhanced Planning Workflow
```

### 基础计划提示词

**位置**: `packages/opencode/src/session/prompt/plan.txt`

```
<system-reminder>
# Plan Mode - System Reminder

CRITICAL: Plan mode ACTIVE - you are in READ-ONLY phase.
STRICTLY FORBIDDEN: ANY file edits, modifications, or system changes.
...
```

## 计划制定工作流

### 第一阶段：初始理解

**目标**: 通过探索代码库和与用户交互，全面理解用户请求。

#### 1.1 启动 Explore Agent

```typescript
// 用户请求分析
const userRequest = "重构认证系统，添加 OAuth2 支持"

// 并行启动多个探索 Agent
const exploreTasks = [
  TaskTool.execute({
    subagent: "explore",
    description: "查找现有的认证相关文件和模块",
    model: { providerID: "anthropic", modelID: "claude-sonnet-4" }
  }),
  TaskTool.execute({
    subagent: "explore",
    description: "分析当前认证系统的架构和依赖",
    model: { providerID: "anthropic", modelID: "claude-sonnet-4" }
  }),
  TaskTool.execute({
    subagent: "explore",
    description: "查找 OAuth2 的最佳实践和示例",
    model: { providerID: "anthropic", modelID: "claude-sonnet-4" }
  }),
]
```

#### 1.2 使用 AskUserQuestion

```typescript
// 澄清模糊需求
await AskUserQuestion.execute({
  questions: [{
    question: "你希望支持哪些 OAuth2 提供商？",
    header: "OAuth Providers",
    options: [
      { label: "Google", description: "Google OAuth2 登录" },
      { label: "GitHub", description: "GitHub OAuth2 登录" },
      { label: "两者都要", description: "同时支持 Google 和 GitHub" },
    ],
    multiSelect: true,
  }]
})
```

### 第二阶段：规划

**目标**: 使用 Plan Agent 制定详细的实施计划。

#### 2.1 启动 Plan Agent

```typescript
// 将探索结果传递给 Plan Agent
const planResult = await TaskTool.execute({
  subagent: "plan",
  description: `
    基于以下探索结果，制定 OAuth2 集成计划：

    1. 现有认证系统位于：src/auth/
    2. 使用 JWT 进行会话管理
    3. 用户希望支持 Google 和 GitHub OAuth2

    请制定详细的实施计划，包括：
    - 需要创建的新文件
    - 需要修改的现有文件
    - 实施步骤和顺序
    - 潜在风险和缓解措施
  `,
})
```

### 第三阶段：综合

**目标**: 整合所有 Agent 的响应，识别关键文件。

#### 3.1 收集 Agent 响应

```typescript
const results = {
  explore: {
    existingAuth: [
      "src/auth/index.ts",
      "src/auth/jwt.ts",
      "src/auth/middleware.ts",
    ],
    dependencies: ["jsonwebtoken", "bcrypt"],
  },
  plan: {
    newFiles: [
      "src/auth/oauth2.ts",
      "src/auth/providers/google.ts",
      "src/auth/providers/github.ts",
    ],
    steps: [
      "1. 安装 OAuth2 依赖",
      "2. 创建基础 OAuth2 抽象",
      "3. 实现 Google Provider",
      "4. 实现 GitHub Provider",
      "5. 集成到现有认证流程",
      "6. 添加测试",
    ],
  },
}
```

#### 3.2 读取关键文件

```typescript
// 在实施前读取需要修改的关键文件
const criticalFiles = [
  "src/auth/index.ts",
  "src/auth/middleware.ts",
  "config/auth.ts",
]

for (const file of criticalFiles) {
  await ReadTool.execute({ path: file })
}
```

### 第四阶段：最终计划

**目标**: 将综合后的计划写入计划文件。

#### 4.1 写入计划文件

```typescript
// 计划文件路径
const planPath = Session.plan({
  slug: session.slug,
  time: { created: session.time.created }
})
// 例如: /project/.opencode/plans/1234567890-my-plan.md

// 写入计划内容
await WriteTool.execute({
  path: planPath,
  content: `# OAuth2 集成计划

## 概述
添加 Google 和 GitHub OAuth2 登录支持到现有认证系统。

## 需要修改的文件

### 核心文件
- \`src/auth/index.ts\` - 添加 OAuth2 初始化
- \`src/auth/middleware.ts\` - 支持 OAuth2 回调

### 需要创建的文件
- \`src/auth/oauth2.ts\` - OAuth2 基础实现
- \`src/auth/providers/google.ts\` - Google OAuth2
- \`src/auth/providers/github.ts\` - GitHub OAuth2

## 实施步骤

1. 安装依赖
   \`\`\`bash
   npm install axios grant
   \`\`\`

2. 创建 OAuth2 基础模块
   - 定义 OAuth2Provider 接口
   - 实现令牌交换逻辑
   - 实现用户信息获取

3. 实现 Google Provider
   - 配置 Google OAuth2 端点
   - 实现授权流程
   - 处理回调

4. 实现 GitHub Provider
   - 配置 GitHub OAuth2 端点
   - 实现授权流程
   - 处理回调

5. 集成到现有系统
   - 更新登录路由
   - 更新用户模型
   - 添加会话管理

6. 测试
   - 单元测试
   - 集成测试
   - 手动测试

## 风险和缓解

- **令牌泄露**: 使用安全的存储和 HTTPS
- **CSRF 攻击**: 实现 state 参数验证
- **会话固定**: 重新生成会话 ID
`
})
```

### 第五阶段：退出计划模式

**目标**: 调用 ExitPlanMode 通知用户计划完成。

```typescript
// 调用 ExitPlanMode 工具
await ExitPlanMode.execute({
  launchSwarm: false,  // 是否启动 swarm 并行执行
})
```

## 计划模式中的工具限制

### 只读工具（允许使用）

- `read` - 读取文件内容
- `grep` - 搜索文件内容
- `glob` - 查找文件
- `bash` - 只读命令（ls, git log, 等）
- `webfetch` - 获取网页内容
- `websearch` - 网络搜索
- `ask` - 向用户提问
- `task` - 启动子 Agent
- `write` - 仅限写入计划文件
- `exit_plan_mode` - 退出计划模式

### 禁用工具（不允许使用）

- `edit` - 编辑文件
- `bash` - 写操作命令（rm, mv, mkdir, 等）
- 任何会修改文件系统的工具

## 计划文件位置

**位置**: `packages/opencode/src/session/index.ts`

```typescript
export function plan(input: {
  slug: string
  time: { created: number }
}) {
  return path.join(
    Instance.worktree,
    ".opencode",
    "plans",
    [input.time.created, input.slug].join("-") + ".md"
  )
}
```

**示例路径**:
```
/home/user/project/.opencode/plans/1704067200000-happy-waddling-feigenbaum.md
```

## 从计划到执行

### 用户批准后

```typescript
// 1. 用户点击 "Execute Plan"
// 2. 系统切换到 build agent（或其他执行 agent）
// 3. 计划文件作为上下文传入

POST /session/:sessionID/message
{
  "agent": "build",
  "parts": [
    {
      "type": "text",
      "text": "执行计划: .opencode/plans/1704067200000-oauth2-integration.md"
    }
  ]
}
```

### 实施过程中的计划引用

```typescript
// 系统提示词会包含计划内容
const planContent = await fs.readFile(planPath, "utf-8")

const systemPrompt = `
You are executing the following plan:

${planContent}

Follow the steps outlined in the plan.
`
```

## 计划模式的优势

1. **降低风险**: 在执行前充分理解影响范围
2. **提高质量**: 经过深思熟虑的计划更少错误
3. **用户参与**: 用户可以在执行前审查和修改计划
4. **可追溯性**: 计划文件记录了决策过程
5. **可复用性**: 计划可以作为文档保存

## 最佳实践

### 1. 探索策略

- **启动 1-3 个 Explore Agent**: 不要过度使用
- **并行执行**: 同时探索不同方面
- **具体描述**: 给每个 Agent 明确的探索目标

### 2. 提问策略

- **早期澄清**: 在探索前先问关键问题
- **权衡选择**: 对于有争议的决策询问用户意见
- **避免假设**: 不确定时就问，不要猜测

### 3. 计划编写

- **全面但简洁**: 包含必要细节但不要啰嗦
- **结构化**: 使用清晰的章节和步骤
- **可验证**: 每个步骤应该有明确的完成标准

### 4. 关键文件识别

- **修改文件**: 列出所有需要修改的现有文件
- **新建文件**: 列出所有需要创建的新文件
- **读取顺序**: 按依赖关系排列文件读取顺序
