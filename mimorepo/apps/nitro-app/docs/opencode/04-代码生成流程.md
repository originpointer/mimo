# OpenCode 代码生成流程

## 概述

本文档详细说明 OpenCode 如何通过 LLM 流式响应处理、工具执行、文件修改和代码生成的完整流程。

## 核心处理器: SessionProcessor

### 位置
`packages/opencode/src/session/processor.ts`

### 创建处理器

```typescript
export function create(input: {
  assistantMessage: MessageV2.Assistant
  sessionID: string
  model: Provider.Model
  abort: AbortSignal
}) {
  const toolcalls: Record<string, MessageV2.ToolPart> = {}
  let snapshot: string | undefined
  let blocked = false
  let attempt = 0
  let needsCompaction = false

  return {
    get message() { return input.assistantMessage },
    partFromToolCall(toolCallID: string) { return toolcalls[toolCallID] },
    async process(streamInput: LLM.StreamInput) {
      // 处理流式响应
    },
  }
}
```

## 流式响应处理

### LLM.stream()

**位置**: `packages/opencode/src/session/llm.ts`

```typescript
export async function* stream(input: StreamInput) {
  const { model, messages, tools, abort } = input

  // 获取语言模型
  const language = await Provider.getLanguage(model)

  // 注册工具
  const toolDefs = await ToolRegistry.register(tools)

  // 使用 Vercel AI SDK
  const stream = await generateText({
    model: language,
    messages: [...systemMessages, ...messages],
    tools: toolDefs,
    temperature: input.temperature ?? 0.3,
    topP: input.topP,
    maxTokens: OUTPUT_TOKEN_MAX,
    abortSignal: abort,
    experimental_continue: true,
    experimental_telemetry: {
      isEnabled: cfg.experimental?.openTelemetry,
    },
  })

  yield* stream.fullStream
}
```

### 流事件类型

```typescript
// 来自 Vercel AI SDK 的事件类型
type StreamEvent =
  | { type: "start" }
  | { type: "reasoning-start"; id: string }
  | { type: "reasoning-delta"; id: string; text: string }
  | { type: "reasoning-end"; id: string }
  | { type: "text-start" }
  | { type: "text-delta"; text: string }
  | { type: "text-end" }
  | { type: "tool-input-start"; id: string; toolName: string }
  | { type: "tool-input-delta"; id: string; text: string }
  | { type: "tool-input-end"; id: string }
  | { type: "tool-call"; toolCallId: string; toolName: string; input: any }
  | { type: "tool-result"; toolCallId: string; input: any; output: ToolOutput }
  | { type: "tool-error"; toolCallId: string; input: any; error: Error }
  | { type: "start-step" }
  | { type: "finish-step"; finishReason: string; usage: LanguageModelUsage }
  | { type: "finish" }
  | { type: "error"; error: Error }
```

## 事件处理详解

### 1. Reasoning 事件 (扩展思考)

```typescript
case "reasoning-start": {
  if (value.id in reasoningMap) continue

  reasoningMap[value.id] = {
    id: Identifier.ascending("part"),
    messageID: input.assistantMessage.id,
    sessionID: input.assistantMessage.sessionID,
    type: "reasoning",
    text: "",
    time: { start: Date.now() },
    metadata: value.providerMetadata,
  }
  break
}

case "reasoning-delta": {
  if (value.id in reasoningMap) {
    const part = reasoningMap[value.id]
    part.text += value.text
    if (value.providerMetadata) part.metadata = value.providerMetadata
    // 增量更新，实时显示给用户
    if (part.text)
      await Session.updatePart({ part, delta: value.text })
  }
  break
}

case "reasoning-end": {
  if (value.id in reasoningMap) {
    const part = reasoningMap[value.id]
    part.text = part.text.trimEnd()
    part.time = {
      ...part.time,
      end: Date.now(),
    }
    if (value.providerMetadata) part.metadata = value.providerMetadata
    await Session.updatePart(part)
    delete reasoningMap[value.id]
  }
  break
}
```

**ReasoningPart 数据结构**:
```typescript
export const ReasoningPart = PartBase.extend({
  type: z.literal("reasoning"),
  text: z.string(),
  metadata: z.record(z.string(), z.any()).optional(),
  time: z.object({
    start: z.number(),
    end: z.number().optional(),
  }),
})
```

### 2. Text 事件 (文本输出)

```typescript
case "text-start": {
  currentText = {
    id: Identifier.ascending("part"),
    messageID: input.assistantMessage.id,
    sessionID: input.assistantMessage.sessionID,
    type: "text",
    text: "",
    time: { start: Date.now() },
    metadata: value.providerMetadata,
  }
  break
}

case "text-delta": {
  if (currentText) {
    currentText.text += value.text
    if (value.providerMetadata)
      currentText.metadata = value.providerMetadata
    // 增量更新，流式显示
    if (currentText.text)
      await Session.updatePart({
        part: currentText,
        delta: value.text,
      })
  }
  break
}

case "text-end": {
  if (currentText) {
    currentText.text = currentText.text.trimEnd()

    // 触发插件钩子
    const textOutput = await Plugin.trigger(
      "experimental.text.complete",
      { sessionID, messageID, partID: currentText.id },
      { text: currentText.text }
    )
    currentText.text = textOutput.text

    currentText.time = {
      start: Date.now(),
      end: Date.now(),
    }
    if (value.providerMetadata)
      currentText.metadata = value.providerMetadata
    await Session.updatePart(currentText)
  }
  currentText = undefined
  break
}
```

### 3. Tool Call 事件 (工具调用)

```typescript
case "tool-input-start": {
  // 创建工具调用占位符
  const part = await Session.updatePart({
    id: toolcalls[value.id]?.id ?? Identifier.ascending("part"),
    messageID: input.assistantMessage.id,
    sessionID: input.assistantMessage.sessionID,
    type: "tool",
    tool: value.toolName,
    callID: value.id,
    state: {
      status: "pending",
      input: {},
      raw: "",
    },
  })
  toolcalls[value.id] = part as MessageV2.ToolPart
  break
}

case "tool-call": {
  const match = toolcalls[value.toolCallId]
  if (match) {
    // 更新为运行状态
    const part = await Session.updatePart({
      ...match,
      tool: value.toolName,
      state: {
        status: "running",
        input: value.input,
        time: { start: Date.now() },
      },
      metadata: value.providerMetadata,
    })
    toolcalls[value.toolCallId] = part as MessageV2.ToolPart

    // 死循环检测
    const parts = await MessageV2.parts(input.assistantMessage.id)
    const lastThree = parts.slice(-DOOM_LOOP_THRESHOLD)

    if (
      lastThree.length === DOOM_LOOP_THRESHOLD &&
      lastThree.every(p =>
        p.type === "tool" &&
        p.tool === value.toolName &&
        p.state.status !== "pending" &&
        JSON.stringify(p.state.input) === JSON.stringify(value.input)
      )
    ) {
      // 检测到重复的工具调用
      const agent = await Agent.get(input.assistantMessage.agent)
      await PermissionNext.ask({
        permission: "doom_loop",
        patterns: [value.toolName],
        sessionID: input.assistantMessage.sessionID,
        metadata: { tool: value.toolName, input: value.input },
        always: [value.toolName],
        ruleset: agent.permission,
      })
    }

    // 执行工具
    const result = await Tool.execute({
      name: value.toolName,
      input: value.input,
      sessionID: input.assistantMessage.sessionID,
      messageID: input.assistantMessage.id,
      agent: input.assistantMessage.agent,
    })
  }
  break
}
```

**ToolPart 数据结构**:
```typescript
export const ToolPart = PartBase.extend({
  type: z.literal("tool"),
  callID: z.string(),
  tool: z.string(),
  state: ToolState,
  metadata: z.record(z.string(), z.any()).optional(),
})

export type ToolState =
  | ToolStatePending    // { status: "pending", input, raw }
  | ToolStateRunning    // { status: "running", input, time }
  | ToolStateCompleted  // { status: "completed", input, output, title, metadata, time, attachments }
  | ToolStateError      // { status: "error", input, error, metadata, time }
```

### 4. Tool Result 事件 (工具结果)

```typescript
case "tool-result": {
  const match = toolcalls[value.toolCallId]
  if (match && match.state.status === "running") {
    await Session.updatePart({
      ...match,
      state: {
        status: "completed",
        input: value.input,
        output: value.output.output,
        metadata: value.output.metadata,
        title: value.output.title,
        time: {
          start: match.state.time.start,
          end: Date.now(),
        },
        attachments: value.output.attachments,
      },
    })
    delete toolcalls[value.toolCallId]
  }
  break
}
```

### 5. Step 事件 (推理步骤)

```typescript
case "start-step": {
  // 开始新的推理步骤，创建快照
  snapshot = await Snapshot.track()
  await Session.updatePart({
    id: Identifier.ascending("part"),
    messageID: input.assistantMessage.id,
    sessionID: input.sessionID,
    snapshot,
    type: "step-start",
  })
  break
}

case "finish-step": {
  // 完成推理步骤
  const usage = Session.getUsage({
    model: input.model,
    usage: value.usage,
    metadata: value.providerMetadata,
  })

  // 更新消息统计
  input.assistantMessage.finish = value.finishReason
  input.assistantMessage.cost += usage.cost
  input.assistantMessage.tokens = usage.tokens

  // 记录步骤结束
  await Session.updatePart({
    id: Identifier.ascending("part"),
    reason: value.finishReason,
    snapshot: await Snapshot.track(),
    messageID: input.assistantMessage.id,
    sessionID: input.sessionID,
    type: "step-finish",
    tokens: usage.tokens,
    cost: usage.cost,
  })

  // 生成并保存补丁
  if (snapshot) {
    const patch = await Snapshot.patch(snapshot)
    if (patch.files.length) {
      await Session.updatePart({
        id: Identifier.ascending("part"),
        messageID: input.assistantMessage.id,
        sessionID: input.sessionID,
        type: "patch",
        hash: patch.hash,
        files: patch.files,
      })
    }
    snapshot = undefined
  }

  // 检查是否需要压缩
  if (await SessionCompaction.isOverflow({ tokens: usage.tokens, model: input.model })) {
    needsCompaction = true
  }
  break
}
```

## 工具执行系统

### Tool.execute()

**位置**: `packages/opencode/src/tool/tool.ts`

```typescript
export async function execute(input: {
  name: string
  input: any
  sessionID: string
  messageID: string
  agent: string
}): Promise<ToolOutput> {
  // 1. 获取工具定义
  const toolDef = ToolRegistry.get(input.name)

  // 2. 检查权限
  const agent = await Agent.get(input.agent)
  const permission = PermissionNext.check({
    permission: input.name,
    pattern: "*",  // 或具体模式
    ruleset: agent.permission,
  })

  if (!permission.allowed) {
    if (permission.action === "deny") {
      throw new PermissionNext.RejectedError(
        `Tool ${input.name} is not allowed`,
        { tool: input.name }
      )
    }
    // action === "ask"，请求用户批准
    const approved = await PermissionNext.ask({
      permission: input.name,
      patterns: [input.name],
      sessionID: input.sessionID,
      ruleset: agent.permission,
    })
    if (!approved) {
      throw new PermissionNext.RejectedError(
        `Tool ${input.name} was denied by user`,
        { tool: input.name }
      )
    }
  }

  // 3. 执行工具
  try {
    const result = await toolDef.execute(input.input, {
      sessionID: input.sessionID,
      messageID: input.messageID,
      agent: input.agent,
    })

    return {
      output: result,
      metadata: {},
      title: toolDef.title ?? input.name,
      attachments: [],
    }
  } catch (error) {
    throw error
  }
}
```

### 工具注册表

**位置**: `packages/opencode/src/tool/registry.ts`

```typescript
export namespace ToolRegistry {
  const tools = new Map<string, Tool.Definition>()

  export function register(tool: Tool.Definition) {
    tools.set(tool.name, tool)
  }

  export function get(name: string): Tool.Definition | undefined {
    return tools.get(name)
  }

  export async function registerForAI() {
    return Array.from(tools.values()).map(tool => ({
      name: tool.name,
      description: tool.description,
      parameters: zodToJsonSchema(tool.inputSchema),
    }))
  }
}
```

## 文件修改流程

### 1. Edit Tool

```typescript
export const EditTool = Tool.define({
  name: "edit",
  description: "Edit a file by replacing exact text",
  inputSchema: z.object({
    path: z.string(),
    oldText: z.string(),
    newText: z.string(),
  }),
  async execute(input, context) {
    // 1. 读取文件
    const content = await fs.readFile(input.path, "utf-8")

    // 2. 验证 oldText 存在
    if (!content.includes(input.oldText)) {
      throw new Error("oldText not found in file")
    }

    // 3. 替换
    const newContent = content.replace(input.oldText, input.newText)

    // 4. 写入
    await fs.writeFile(input.path, newContent, "utf-8")

    return {
      output: `Successfully edited ${input.path}`,
      title: "Edit file",
    }
  },
})
```

### 2. Write Tool

```typescript
export const WriteTool = Tool.define({
  name: "write",
  description: "Write content to a file",
  inputSchema: z.object({
    path: z.string(),
    content: z.string(),
  }),
  async execute(input, context) {
    // 1. 创建目录（如需要）
    const dir = path.dirname(input.path)
    await fs.mkdir(dir, { recursive: true })

    // 2. 写入文件
    await fs.writeFile(input.path, input.content, "utf-8")

    return {
      output: `Successfully wrote ${input.path}`,
      title: "Write file",
    }
  },
})
```

## 快照和补丁系统

### Snapshot.track()

**位置**: `packages/opencode/src/snapshot/index.ts`

```typescript
export async function track(): Promise<string> {
  const hash = await git.revparse("HEAD")
  const status = await git.status()

  // 记录当前文件系统状态
  const state = {
    hash,
    files: await scanFiles(Instance.directory),
  }

  return JSON.stringify(state)
}
```

### Snapshot.patch()

```typescript
export async function patch(snapshot: string): Promise<{
  hash: string
  files: string[]
}> {
  const before = JSON.parse(snapshot)
  const after = await git.revparse("HEAD")

  const diff = await git.diff([
    `${before.hash}..${after}`,
    "--name-only",
  ])

  return {
    hash: after,
    files: diff.split("\n").filter(Boolean),
  }
}
```

## 错误处理和重试

### SessionRetry.retryable()

**位置**: `packages/opencode/src/session/retry.ts`

```typescript
export function retryable(error: MessageV2.Error):
  | { name: string; message: string }
  | undefined
{
  if (MessageV2.APIError.isInstance(error)) {
    if (error.isRetryable) {
      return {
        name: "APIError",
        message: "API error, retrying...",
      }
    }
  }
  // 其他不可重试的错误
  return undefined
}

export function delay(attempt: number, apiError?: any): number {
  // 指数退避
  return Math.min(1000 * Math.pow(2, attempt), 30000)
}
```

### 错误处理

```typescript
catch (e: any) {
  const error = MessageV2.fromError(e, {
    providerID: input.model.providerID
  })

  const retry = SessionRetry.retryable(error)
  if (retry !== undefined) {
    attempt++
    const delay = SessionRetry.delay(attempt, error)

    SessionStatus.set(input.sessionID, {
      type: "retry",
      attempt,
      message: retry,
      next: Date.now() + delay,
    })

    await SessionRetry.sleep(delay, input.abort)
    continue  // 重试
  }

  // 不可重试的错误
  input.assistantMessage.error = error
  Bus.publish(Session.Event.Error, {
    sessionID: input.assistantMessage.sessionID,
    error: input.assistantMessage.error,
  })
}
```

## 循环控制

### 完成条件

```typescript
// 1. 达到 finish 状态
if (lastAssistant?.finish &&
    ["stop", "length", "content_filter"].includes(lastAssistant.finish)) {
  break
}

// 2. 用户中止
if (abort.aborted) {
  break
}

// 3. 权限拒绝
if (blocked) {
  return "stop"
}

// 4. 需要压缩
if (needsCompaction) {
  return "compact"
}
```

### 清理未完成的工具调用

```typescript
// 确保所有未完成的工具调用都被标记为错误
const p = await MessageV2.parts(input.assistantMessage.id)
for (const part of p) {
  if (part.type === "tool" &&
      part.state.status !== "completed" &&
      part.state.status !== "error") {
    await Session.updatePart({
      ...part,
      state: {
        ...part.state,
        status: "error",
        error: "Tool execution aborted",
        time: {
          start: Date.now(),
          end: Date.now(),
        },
      },
    })
  }
}
```

## 完整流程示例

```typescript
// 用户: "添加一个用户登录功能"

// 1. 创建用户消息
const userMessage = await createUserMessage({
  sessionID: "sess_123",
  parts: [{ type: "text", text: "添加一个用户登录功能" }]
})

// 2. 启动循环
const result = await SessionPrompt.loop("sess_123")

// 3. 循环内部
while (true) {
  // 4. 构建上下文
  const context = await buildContext({ messages, userMessage })

  // 5. 创建助手消息
  const assistantMessage = await createAssistantMessage({...})

  // 6. 创建处理器
  const processor = SessionProcessor.create({
    assistantMessage,
    sessionID: "sess_123",
    model: { providerID: "anthropic", modelID: "claude-sonnet-4" },
    abort,
  })

  // 7. 处理流式响应
  await processor.process(context)

  // 处理事件...
  // text-delta → 显示文本
  // tool-call → 执行工具
  // tool-result → 显示结果
  // finish-step → 更新状态

  // 8. 检查是否完成
  if (assistantMessage.finish === "stop") break
}

// 9. 返回助手消息
return { info: assistantMessage, parts }
```

## Token 使用和成本计算

### Session.getUsage()

**位置**: `packages/opencode/src/session/index.ts`

```typescript
export const getUsage = fn(z.object({
  model: z.custom<Provider.Model>(),
  usage: z.custom<LanguageModelUsage>(),
  metadata: z.custom<ProviderMetadata>().optional(),
}), (input) => {
  const cachedInputTokens = input.usage.cachedInputTokens ?? 0
  const excludesCachedTokens = !!(
    input.metadata?.["anthropic"] || input.metadata?.["bedrock"]
  )

  const adjustedInputTokens = excludesCachedTokens
    ? input.usage.inputTokens ?? 0
    : (input.usage.inputTokens ?? 0) - cachedInputTokens

  const tokens = {
    input: adjustedInputTokens,
    output: input.usage.outputTokens ?? 0,
    reasoning: input.usage?.reasoningTokens ?? 0,
    cache: {
      write: input.metadata?.["anthropic"]?.["cacheCreationInputTokens"] ?? 0,
      read: cachedInputTokens,
    },
  }

  const costInfo = input.model.cost?.experimentalOver200K &&
    tokens.input + tokens.cache.read > 200_000
    ? input.model.cost.experimentalOver200K
    : input.model.cost

  const cost = new Decimal(0)
    .add(new Decimal(tokens.input).mul(costInfo?.input ?? 0).div(1_000_000))
    .add(new Decimal(tokens.output).mul(costInfo?.output ?? 0).div(1_000_000))
    .add(new Decimal(tokens.cache.read).mul(costInfo?.cache?.read ?? 0).div(1_000_000))
    .add(new Decimal(tokens.cache.write).mul(costInfo?.cache?.write ?? 0).div(1_000_000))
    .add(new Decimal(tokens.reasoning).mul(costInfo?.output ?? 0).div(1_000_000))
    .toNumber()

  return { cost, tokens }
})
```
