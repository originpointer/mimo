# Mimo å¼€å‘é€ŸæŸ¥æ‰‹å†Œ

**ç‰ˆæœ¬**: v1.0.0
**æ›´æ–°æ—¥æœŸ**: 2026-01-22

æœ¬æ–‡æ¡£æä¾› Mimo åŠŸèƒ½åœ¨ apps é¡¹ç›®ä¸­å¿«é€Ÿé›†æˆçš„ä»£ç å‚è€ƒã€‚

---

## ç›®å½•

- [ç¯å¢ƒå‡†å¤‡](#ç¯å¢ƒå‡†å¤‡)
- [åç«¯é›†æˆ (nitro-app)](#åç«¯é›†æˆ-nitro-app)
- [å‰ç«¯é›†æˆ (next-app)](#å‰ç«¯é›†æˆ-next-app)
- [æ‰©å±•é›†æˆ (plasmo-app)](#æ‰©å±•é›†æˆ-plasmo-app)
- [å¸¸ç”¨ä»£ç ç‰‡æ®µ](#å¸¸ç”¨ä»£ç ç‰‡æ®µ)
- [è°ƒè¯•æŠ€å·§](#è°ƒè¯•æŠ€å·§)
- [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)

---

## ç¯å¢ƒå‡†å¤‡

### å¯åŠ¨å¼€å‘ç¯å¢ƒ

```bash
# åœ¨é¡¹ç›®æ ¹ç›®å½•
pnpm install
pnpm dev

# æˆ–åˆ†åˆ«å¯åŠ¨
pnpm --filter nitro-app dev
pnpm --filter next-app dev
```

### ç¯å¢ƒå˜é‡é…ç½®

```bash
# .env
NUXT_OPENAI_API_KEY=sk-xxx
NUXT_ANTHROPIC_API_KEY=sk-xxx
SOCKET_IO_PORT=3000
```

---

## åç«¯é›†æˆ (nitro-app)

### åˆ›å»º Mimo å®ä¾‹

```typescript
// nitro-app/server/lib/mimo.ts
import { Mimo } from '@mimo/core';

let mimoInstance: Mimo | null = null;

export function getMimoInstance(): Mimo {
  if (!mimoInstance) {
    mimoInstance = new Mimo({
      socket: {
        url: process.env.SOCKET_IO_URL || 'ws://localhost:3000',
      },
      verbose: 1,
    });
  }
  return mimoInstance;
}

export async function initMimo() {
  const mimo = getMimoInstance();
  if (!mimo.getBus().isConnected()) {
    await mimo.init();
  }
  return mimo;
}

export async function closeMimo() {
  if (mimoInstance) {
    await mimoInstance.close({ force: true });
    mimoInstance = null;
  }
}
```

### åˆ›å»º API è·¯ç”±

```typescript
// nitro-app/server/routes/api/mimo/act.ts
import { initMimo } from '~/server/lib/mimo';

export default eventHandler(async (event) => {
  try {
    const { input, options } = await readBody(event);

    const mimo = await initMimo();
    const result = await mimo.act(input, options);

    return {
      success: true,
      data: result,
    };
  } catch (error) {
    throw createError({
      statusCode: 500,
      message: error.message,
    });
  }
});
```

### MCP å·¥å…·æ³¨å†Œ

```typescript
// nitro-app/server/plugins/mcp-tools.ts
import { Tool } from '@modelcontextprotocol/sdk/types.js';

export const mimoTools: Tool[] = [
  {
    name: 'mimo_act',
    description: 'ä½¿ç”¨è‡ªç„¶è¯­è¨€æŒ‡ä»¤æ‰§è¡Œæµè§ˆå™¨æ“ä½œ',
    inputSchema: {
      type: 'object',
      properties: {
        instruction: {
          type: 'string',
          description: 'æ“ä½œæŒ‡ä»¤',
        },
      },
      required: ['instruction'],
    },
  },
  // ... æ›´å¤šå·¥å…·
];
```

### Socket.IO äº‹ä»¶å¤„ç†

```typescript
// nitro-app/server/plugins/socket.ts
import { Server } from 'socket.io';

export default defineNitroPlugin((nitroApp) => {
  const io = new Server(nitroApp.h3App.nodeHandler);

  io.on('connection', (socket) => {
    console.log('å®¢æˆ·ç«¯å·²è¿æ¥:', socket.id);

    socket.on('mimo:command', async (data, callback) => {
      const mimo = await initMimo();
      const result = await mimo.act(data.instruction);
      callback(result);
    });

    socket.on('disconnect', () => {
      console.log('å®¢æˆ·ç«¯å·²æ–­å¼€:', socket.id);
    });
  });
});
```

---

## å‰ç«¯é›†æˆ (next-app)

### Chat ç•Œé¢é›†æˆ

```typescript
// next-app/app/chat/page.tsx
'use client';

import { useChat } from '@ai-sdk/react';

export default function ChatPage() {
  const { messages, input, handleInputChange, handleSubmit } = useChat({
    api: '/api/chat',
  });

  return (
    <div className="flex flex-col h-screen">
      <div className="flex-1 overflow-y-auto p-4">
        {messages.map(m => (
          <div key={m.id} className={m.role === 'user' ? 'text-right' : 'text-left'}>
            <div className="inline-block px-4 py-2 rounded-lg bg-gray-100">
              {m.content}
            </div>
          </div>
        ))}
      </div>
      <form onSubmit={handleSubmit} className="p-4 border-t">
        <input
          value={input}
          onChange={handleInputChange}
          className="w-full px-4 py-2 border rounded"
          placeholder="è¾“å…¥æ“ä½œæŒ‡ä»¤..."
        />
      </form>
    </div>
  );
}
```

### Mimo Hook

```typescript
// next-app/hooks/use-mimo.ts
'use client';

import { useState, useCallback } from 'react';

export function useMimo() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const act = useCallback(async (instruction: string) => {
    setLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/mimo/act', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ input: instruction }),
      });

      if (!response.ok) throw new Error('è¯·æ±‚å¤±è´¥');

      const result = await response.json();
      return result.data;
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  const extract = useCallback(async (instruction: string, schema?: any) => {
    setLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/mimo/extract', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ instruction, schema }),
      });

      const result = await response.json();
      return result.data;
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  return { act, extract, loading, error };
}
```

### Agent æ‰§è¡Œç»„ä»¶

```typescript
// next-app/components/agent-executor.tsx
'use client';

import { useState } from 'react';

export function AgentExecutor() {
  const [instruction, setInstruction] = useState('');
  const [events, setEvents] = useState([]);
  const [running, setRunning] = useState(false);

  const execute = async () => {
    setRunning(true);
    setEvents([]);

    const response = await fetch('/api/mimo/agent/stream', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ instruction }),
    });

    const reader = response.body?.getReader();
    const decoder = new TextDecoder();

    while (true) {
      const { done, value } = await reader!.read();
      if (done) break;

      const text = decoder.decode(value);
      const lines = text.split('\n');

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const event = JSON.parse(line.slice(6));
          setEvents(prev => [...prev, event]);
        }
      }
    }

    setRunning(false);
  };

  return (
    <div className="p-4 border rounded">
      <textarea
        value={instruction}
        onChange={e => setInstruction(e.target.value)}
        className="w-full h-32 p-2 border rounded"
        placeholder="è¾“å…¥ä»»åŠ¡æŒ‡ä»¤..."
      />
      <button
        onClick={execute}
        disabled={running}
        className="mt-2 px-4 py-2 bg-blue-500 text-white rounded disabled:bg-gray-400"
      >
        {running ? 'æ‰§è¡Œä¸­...' : 'å¼€å§‹æ‰§è¡Œ'}
      </button>
      <div className="mt-4 space-y-2">
        {events.map((e, i) => (
          <div key={i} className="p-2 bg-gray-50 rounded text-sm">
            {e.type}: {JSON.stringify(e.data)}
          </div>
        ))}
      </div>
    </div>
  );
}
```

---

## æ‰©å±•é›†æˆ (plasmo-app)

### Content Script æ¶ˆæ¯å¤„ç†

```typescript
// plasmo-app/content/index.ts
import type { PlasmoCSConfig } from 'plasmo';

export const config: PlasmoCSConfig = {
  matches: ['<all_urls>'],
};

chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  switch (request.type) {
    case 'PAGE_CLICK':
      const element = document.querySelector(request.selector);
      element?.click();
      sendResponse({ success: true });
      break;

    case 'PAGE_FILL':
      const input = document.querySelector(request.selector) as HTMLInputElement;
      if (input) input.value = request.value;
      sendResponse({ success: true });
      break;

    case 'PAGE_SCREENSHOT':
      // ä½¿ç”¨ Chrome API æˆªå›¾
      chrome.runtime.sendMessage({
        type: 'CAPTURE_SCREENSHOT',
        tabId: request.tabId,
      });
      break;
  }

  return true;
});
```

### Background Script

```typescript
// plasmo-app/background/index.ts
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.type === 'CAPTURE_SCREENSHOT') {
    chrome.tabs.captureVisibleTab(null, { format: 'png' }, (dataUrl) => {
      // è½¬æ¢ä¸º Buffer å¹¶å‘é€
      const base64Data = dataUrl.replace(/^data:image\/png;base64,/, '');
      const buffer = Buffer.from(base64Data, 'base64');

      // é€šè¿‡ Socket.IO å‘é€åˆ°åç«¯
      sendResponse({ success: true, data: buffer });
    });
  }
  return true;
});
```

### XPath ç”Ÿæˆå™¨

```typescript
// plasmo-app/content/xpath.ts
export function generateXPath(element: HTMLElement): string {
  if (element.id) {
    return `//*[@id="${element.id}"]`;
  }

  const parts: string[] = [];
  let current = element;

  while (current && current.nodeType === Node.ELEMENT_NODE) {
    let index = 0;
    let sibling = current.previousSibling;

    while (sibling) {
      if (sibling.nodeType === Node.ELEMENT_NODE && (sibling as HTMLElement).tagName === current.tagName) {
        index++;
      }
      sibling = sibling.previousSibling;
    }

    const tagName = (current as HTMLElement).tagName.toLowerCase();
    const pathIndex = index > 0 ? `[${index + 1}]` : '';
    parts.unshift(`${tagName}${pathIndex}`);

    current = current.parentElement as HTMLElement;
  }

  return '/' + parts.join('/');
}
```

---

## å¸¸ç”¨ä»£ç ç‰‡æ®µ

### é‡è¯•æœºåˆ¶

```typescript
export async function retry<T>(
  fn: () => Promise<T>,
  maxRetries = 3,
  delay = 1000
): Promise<T> {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
    }
  }
  throw new Error('é‡è¯•å¤±è´¥');
}
```

### è¶…æ—¶æ§åˆ¶

```typescript
export async function withTimeout<T>(
  promise: Promise<T>,
  timeout: number
): Promise<T> {
  const timeoutPromise = new Promise<never>((_, reject) => {
    setTimeout(() => reject(new Error(`æ“ä½œè¶…æ—¶: ${timeout}ms`)), timeout);
  });

  return Promise.race([promise, timeoutPromise]);
}
```

### æ‰¹é‡å¤„ç†

```typescript
export async function batchProcess<T, R>(
  items: T[],
  processor: (item: T) => Promise<R>,
  batchSize = 5
): Promise<R[]> {
  const results: R[] = [];

  for (let i = 0; i < items.length; i += batchSize) {
    const batch = items.slice(i, i + batchSize);
    const batchResults = await Promise.all(batch.map(processor));
    results.push(...batchResults);
  }

  return results;
}
```

### é”™è¯¯å¤„ç†åŒ…è£…

```typescript
export function safeHandler<T extends (...args: any[]) => Promise<any>>(
  handler: T
): T {
  return (async (...args: any[]) => {
    try {
      return await handler(...args);
    } catch (error) {
      console.error('Handler error:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }) as T;
}
```

---

## è°ƒè¯•æŠ€å·§

### å¯ç”¨è¯¦ç»†æ—¥å¿—

```typescript
const mimo = new Mimo({
  socket: { url: 'ws://localhost:3000' },
  verbose: 2, // 0=é™é»˜, 1=æ­£å¸¸, 2=è°ƒè¯•
});
```

### ç›‘å¬æ‰€æœ‰äº‹ä»¶

```typescript
mimo.on('connected', () => console.log('âœ… å·²è¿æ¥'));
mimo.on('disconnected', (data) => console.log('âŒ å·²æ–­å¼€:', data));
mimo.on('command.sent', (data) => console.log('ğŸ“¤ å‘é€:', data));
mimo.on('command.result', (data) => console.log('ğŸ“¥ ç»“æœ:', data));
mimo.on('error', (data) => console.error('âš ï¸ é”™è¯¯:', data));
```

### Chrome DevTools è°ƒè¯•

```typescript
// åœ¨æ‰©å±•ä»£ç ä¸­
console.log('[Mimo Debug]', { element, selector, xpath });

// åœ¨ content script ä¸­
debugger; // è®¾ç½®æ–­ç‚¹
```

### Socket.IO è°ƒè¯•

```typescript
// æœåŠ¡ç«¯
io.on('connection', (socket) => {
  console.log('[Socket] è¿æ¥:', socket.id);
  socket.on('debug', (data) => console.log('[Socket] è°ƒè¯•:', data));
});

// å®¢æˆ·ç«¯
socket.emit('debug', { message: 'æµ‹è¯•æ¶ˆæ¯' });
```

---

## å¸¸è§é—®é¢˜

### Q: Socket.IO è¿æ¥å¤±è´¥

**æ£€æŸ¥é¡¹**:
1. åç«¯æœåŠ¡æ˜¯å¦å¯åŠ¨
2. ç«¯å£é…ç½®æ˜¯å¦æ­£ç¡®
3. CORS é…ç½®æ˜¯å¦æ­£ç¡®

**è§£å†³æ–¹æ¡ˆ**:

```typescript
// nitro-app/server/plugins/socket.ts
io.use((socket, next) => {
  const origin = socket.handshake.headers.origin;
  // å…è®¸çš„æº
  if (['http://localhost:3000', 'http://localhost:3001'].includes(origin)) {
    next();
  } else {
    next(new Error('Origin not allowed'));
  }
});
```

### Q: æ‰©å±•æ— æ³•é€šä¿¡

**æ£€æŸ¥é¡¹**:
1. manifest.json æƒé™é…ç½®
2. externally_connectable é…ç½®

**è§£å†³æ–¹æ¡ˆ**:

```json
// plasmo-app/package.json
{
  "manifest": {
    "permissions": ["debugger", "tabs", "activeTab"],
    "externally_connectable": {
      "matches": ["http://localhost:*/*"]
    }
  }
}
```

### Q: LLM API è°ƒç”¨å¤±è´¥

**æ£€æŸ¥é¡¹**:
1. API Key æ˜¯å¦æ­£ç¡®
2. ä½™é¢æ˜¯å¦å……è¶³
3. è¯·æ±‚é¢‘ç‡é™åˆ¶

**è§£å†³æ–¹æ¡ˆ**:

```typescript
// nitro-app/server/lib/llm.ts
export async function callWithRetry(fn, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (error.status === 429) {
        // é€Ÿç‡é™åˆ¶ï¼Œç­‰å¾…åé‡è¯•
        await new Promise(resolve => setTimeout(resolve, 5000 * (i + 1)));
      } else if (i === maxRetries - 1) {
        throw error;
      }
    }
  }
}
```

### Q: Agent ä»»åŠ¡æ‰§è¡Œå¡ä½

**æ£€æŸ¥é¡¹**:
1. maxSteps è®¾ç½®
2. è¶…æ—¶é…ç½®
3. é¡µé¢åŠ è½½çŠ¶æ€

**è§£å†³æ–¹æ¡ˆ**:

```typescript
const agent = mimo.agent({
  model: 'openai/gpt-4o-mini',
  maxSteps: 25,
});

const result = await withTimeout(
  agent.execute({ instruction: '...' }),
  300000 // 5 åˆ†é’Ÿè¶…æ—¶
);
```

---

## å¿«æ·å‘½ä»¤

```bash
# å¯åŠ¨æ‰€æœ‰æœåŠ¡
pnpm dev

# åªå¯åŠ¨åç«¯
pnpm --filter nitro-app dev

# åªå¯åŠ¨å‰ç«¯
pnpm --filter next-app dev

# æ„å»ºæ‰©å±•
pnpm --filter plasmo-app build

# è¿è¡Œæµ‹è¯•
pnpm test

# ä»£ç æ£€æŸ¥
pnpm lint
```

---

## ç›¸å…³é“¾æ¥

- [å®Œæ•´é›†æˆè®¡åˆ’](./01-æ¸è¿›å¼é›†æˆè®¡åˆ’.md)
- [å¿«é€Ÿå¼€å§‹](../00-å¿«é€Ÿå¼€å§‹.md)
- [API å‚è€ƒ](../02-APIå‚è€ƒ.md)
