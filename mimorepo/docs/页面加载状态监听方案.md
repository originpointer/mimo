# 页面加载状态监听方案

## 一、MV3 中可用于页面加载状态判断的状态信息

### 1.1 浏览器 API 状态信息

#### Document 状态

- `document.readyState`: `loading` | `interactive` | `complete`
  - `loading`: 文档仍在加载
  - `interactive`: 文档已完成解析，但仍在加载子资源
  - `complete`: 文档和所有子资源已完成加载
- `document.hidden`: 页面是否隐藏（用于判断页面可见性）
- `document.visibilityState`: `visible` | `hidden` | `prerender`
- `document.hasFocus()`: 页面是否获得焦点

#### Window 事件

- `window.load`: 页面及其所有资源加载完成
- `window.DOMContentLoaded`: DOM 解析完成（不等待样式表、图片等）
- `window.beforeunload`: 页面即将卸载
- `window.unload`: 页面正在卸载
- `window.pageshow`: 页面显示（包括前进/后退缓存恢复）
- `window.pagehide`: 页面隐藏

#### Performance API

- `performance.timing`: 包含各种时间戳（已废弃，但部分浏览器仍支持）
- `performance.getEntriesByType('navigation')`: 获取导航性能条目
  - `domContentLoadedEventStart/End`: DOM 内容加载时间
  - `loadEventStart/End`: 页面加载时间
  - `domInteractive`: DOM 可交互时间
- `performance.getEntriesByType('resource')`: 获取资源加载性能条目
  - 可以检测图片、脚本、样式表等资源的加载状态
- `performance.now()`: 高精度时间戳
- `performance.getEntriesByType('paint')`: 获取绘制性能指标
  - `first-paint`: 首次绘制
  - `first-contentful-paint`: 首次内容绘制

#### Network 状态

- `navigator.onLine`: 网络连接状态
- `navigator.connection`: 网络连接信息（类型、速度等）
  - `effectiveType`: 连接类型（4g, 3g 等）
  - `downlink`: 下行速度
  - `rtt`: 往返时间

#### 资源加载状态

- `document.fonts.ready`: Promise，字体加载完成
- `document.images`: 所有图片元素，可检查 `img.complete`
- `document.styleSheets`: 样式表集合，可检查加载状态
- `document.scripts`: 脚本集合

### 1.2 Chrome Extension API 状态信息

#### chrome.webNavigation API

- `chrome.webNavigation.onBeforeNavigate`: 导航开始前
  - 提供 `tabId`, `url`, `frameId`, `timeStamp`
- `chrome.webNavigation.onCommitted`: 导航已提交
  - 提供 `tabId`, `url`, `frameId`, `transitionType`
- `chrome.webNavigation.onDOMContentLoaded`: DOM 内容加载完成
  - 提供 `tabId`, `url`, `frameId`, `timeStamp`
- `chrome.webNavigation.onCompleted`: 页面加载完成
  - 提供 `tabId`, `url`, `frameId`, `timeStamp`
- `chrome.webNavigation.onErrorOccurred`: 加载错误
  - 提供 `tabId`, `url`, `frameId`, `error`
- `chrome.webNavigation.onHistoryStateUpdated`: 历史状态更新（SPA 路由变化）
  - 提供 `tabId`, `url`, `frameId`, `timeStamp`
- `chrome.webNavigation.getAllFrames()`: 获取所有 frames（包括 iframe）

#### chrome.tabs API

- `chrome.tabs.onUpdated`: Tab 状态变化
  - `status`: `loading` | `complete`
  - `url`: URL 变化
  - `title`: 标题变化
- `chrome.tabs.query()`: 查询 Tab 状态
  - 可以获取当前活动 tab 的状态
- `chrome.tabs.get()`: 获取特定 tab 的详细信息

#### chrome.scripting API

- 脚本注入状态
- 执行结果反馈
- `chrome.scripting.executeScript()`: 可以检测脚本执行是否成功

#### chrome.runtime API

- `chrome.runtime.sendMessage()`: 与 content script 通信
- `chrome.runtime.onMessage`: 接收来自 content script 的消息

### 1.3 DOM Observer 状态信息

#### MutationObserver

- DOM 树变化：节点添加、删除、属性变化
- 文本内容变化
- 子节点变化
- 配置选项：
  - `childList`: 监听子节点变化
  - `attributes`: 监听属性变化
  - `characterData`: 监听文本内容变化
  - `subtree`: 监听所有后代节点
  - `attributeOldValue`: 记录属性旧值
  - `characterDataOldValue`: 记录文本旧值

#### IntersectionObserver

- 元素进入/离开视口
- 元素可见性变化
- 可以检测懒加载内容
- 配置选项：
  - `root`: 观察的根元素
  - `rootMargin`: 根边距
  - `threshold`: 触发阈值

#### ResizeObserver

- 元素尺寸变化
- 视口尺寸变化
- 可以检测布局变化

#### PerformanceObserver

- 性能指标变化
- 资源加载性能
- 长任务检测
- 可以监听：
  - `navigation`: 导航性能
  - `resource`: 资源加载性能
  - `paint`: 绘制性能
  - `longtask`: 长任务

### 1.4 自定义状态指标

#### 关键元素检测

- 特定选择器元素是否存在
- 关键元素是否可见
- 关键元素内容是否加载完成
- 使用 `document.querySelector()` 或 `document.querySelectorAll()`

#### 异步资源检测

- 图片加载状态（`img.complete`, `img.naturalWidth > 0`）
- 脚本执行状态
- 样式表加载状态（`sheet.cssRules` 或 `sheet.rules`）
- 字体加载状态（`document.fonts.ready`）
- 视频/音频加载状态（`video.readyState`）

#### 框架特定状态

- React: `__REACT_DEVTOOLS_GLOBAL_HOOK__`
- Vue: `window.__VUE__`
- Angular: `window.ng`
- 框架路由状态变化
- 框架生命周期钩子

#### 加载指示器检测

- Loading spinner 是否存在/可见
- 骨架屏（skeleton screen）是否存在
- 进度条状态
- 常见选择器：`[class*="loading"]`, `[class*="spinner"]`, `[class*="skeleton"]`

## 二、SPA 页面加载状态判断 - 苏格拉底式提问分析

### 2.1 初始加载阶段

**Q1: SPA 的初始加载和传统页面有什么不同？**

- A: SPA 只加载一次 HTML，后续通过 JavaScript 动态更新 DOM
- 判断要点：`DOMContentLoaded` 后，DOM 可能仍在动态变化
- 关键区别：SPA 的"页面加载"实际上是"应用初始化" + "路由渲染"

**Q2: 如何判断 SPA 的初始渲染是否完成？**

- A: 需要结合多个指标：
  - `document.readyState === 'complete'`
  - 关键元素是否存在且可见（如主容器、导航栏等）
  - 网络请求是否完成（通过 PerformanceObserver）
  - 框架是否完成初始化（如果可检测）
  - 没有明显的加载指示器

**Q3: 如何检测 SPA 的路由变化？**

- A: 多种方式：
  - `chrome.webNavigation.onHistoryStateUpdated`（最可靠，在 background 中）
  - `popstate` 事件（在 content script 中）
  - `pushState`/`replaceState` 拦截（需要重写 `history.pushState` 和 `history.replaceState`）
  - URL 变化检测（`location.href` 或 `MutationObserver` 监听）
  - 框架路由事件（如果框架暴露了路由 API）

**Q4: 路由变化后，如何判断新页面内容已加载完成？**

- A: 需要检测：
  - URL 变化（已确认）
  - DOM 关键区域变化（MutationObserver 监听主内容区域）
  - 网络请求完成（新的 API 调用，通过 PerformanceObserver）
  - 框架路由状态更新（如果可检测）
  - 加载指示器消失
  - 内容区域稳定（一段时间内无 DOM 变化）

**Q5: SPA 中如何区分"加载中"和"加载完成"？**

- A: 综合判断：
  - Loading 指示器是否存在/可见
  - 骨架屏是否存在
  - 关键内容区域是否有实际内容（不是占位符）
  - 网络请求是否活跃（通过 PerformanceObserver）
  - DOM 是否稳定（MutationObserver 检测稳定期）

### 2.2 动态内容加载

**Q6: SPA 中异步加载的内容如何检测？**

- A: 使用 MutationObserver 监听：
  - 特定容器的子节点变化（如列表容器、卡片容器）
  - 特定属性的变化（如 `data-loaded`, `data-state`）
  - 文本内容的变化
  - 类名的变化（如从 `loading` 变为 `loaded`）

**Q7: 如何判断懒加载的内容已加载？**

- A: 结合 IntersectionObserver 和资源加载：
  - 元素进入视口（IntersectionObserver）
  - 相关资源（图片、数据）加载完成（PerformanceObserver 或资源事件）
  - 元素内容填充完成（MutationObserver 检测内容变化）
  - 元素尺寸稳定（ResizeObserver）

**Q8: SPA 中的错误状态如何检测？**

- A: 检测错误指示器：
  - 错误消息元素（常见选择器：`[class*="error"]`, `[class*="alert"]`）
  - 网络错误状态（`navigator.onLine` 或网络请求失败）
  - 框架错误边界（如果可检测）
  - HTTP 错误状态码（通过 PerformanceObserver 检测失败的请求）

**Q9: 如何检测 SPA 中的无限滚动加载？**

- A: 结合多种 Observer：
  - IntersectionObserver 检测滚动到底部
  - MutationObserver 检测新内容添加
  - PerformanceObserver 检测新的网络请求
  - 检测加载指示器出现和消失

### 2.3 状态管理

**Q10: 如何判断 SPA 的状态管理是否就绪？**

- A: 检测框架状态：
  - React: 检查 `__REACT_DEVTOOLS_GLOBAL_HOOK__` 或 Redux store
  - Vue: 检查 `window.__VUE__` 或 Vuex store
  - Angular: 检查 `window.ng` 或服务状态
  - 检测关键数据是否已加载（通过 DOM 内容判断）

## 三、非 SPA 页面加载状态判断 - 苏格拉底式提问分析

### 3.1 传统页面加载流程

**Q1: 传统页面的加载阶段有哪些？**

- A: 典型流程：
  1. `document.readyState === 'loading'`: 初始加载，HTML 解析中
  2. `DOMContentLoaded`: DOM 解析完成，但资源可能仍在加载
  3. `document.readyState === 'interactive'`: 可交互，但资源仍在加载
  4. `window.load`: 所有资源加载完成
  5. `document.readyState === 'complete'`: 完全加载

**Q2: 如何判断传统页面是否真正加载完成？**

- A: 需要检查：
  - `document.readyState === 'complete'`
  - 所有关键资源加载完成（图片、样式、脚本）
  - 关键元素可见（不是被 CSS 隐藏）
  - 没有正在进行的网络请求（通过 PerformanceObserver）
  - 没有明显的加载指示器

**Q3: 传统页面中的异步内容如何检测？**

- A: 使用 MutationObserver：
  - 监听动态插入的内容（广告、评论、推荐内容等）
  - 检测广告、评论等异步加载的内容
  - 监听 iframe 加载状态
  - 检测第三方脚本插入的内容

**Q4: 如何判断 iframe 的加载状态？**

- A: 多种方式：
  - `iframe.contentWindow` 访问（同源 iframe）
  - `iframe.onload` 事件（同源和跨域都可用）
  - `chrome.webNavigation` API（跨域 iframe，在 background 中）
  - iframe 内容检测（MutationObserver 监听 iframe 内部变化，仅同源）
  - `iframe.contentDocument.readyState`（仅同源）

**Q5: 传统页面的导航和 SPA 导航有什么不同？**

- A: 传统页面导航会触发完整的页面重新加载：
  - `beforeunload` → 新页面 `loading` → `DOMContentLoaded` → `load`
  - 可以通过 `chrome.webNavigation` API 完整追踪
  - 每个导航都是独立的加载周期

**Q6: 如何检测页面是否正在导航？**

- A: 检测指标：
  - `document.readyState === 'loading'`（新页面开始加载）
  - `chrome.webNavigation.onBeforeNavigate`（在 background 中）
  - URL 变化但 DOM 未更新（通过比较 `location.href` 和当前 DOM）
  - `window.beforeunload` 事件触发

### 3.2 资源加载检测

**Q7: 如何检测关键资源是否加载完成？**

- A: 多种方式：
  - `performance.getEntriesByType('resource')` 检查资源状态
  - `document.images` 检查图片 `complete` 属性
  - `document.styleSheets` 检查样式表加载
  - `document.scripts` 检查脚本执行
  - PerformanceObserver 监听资源加载事件

**Q8: 如何处理资源加载失败的情况？**

- A: 检测方式：
  - PerformanceObserver 检测失败的资源请求
  - `img.onerror` 事件（需要手动绑定）
  - `link.onerror` 事件（样式表加载失败）
  - `script.onerror` 事件（脚本加载失败）
  - 检查资源元素的 `naturalWidth === 0`（图片）

### 3.3 特殊场景

**Q9: 如何处理页面从缓存恢复的情况？**

- A: 检测方式：
  - `window.pageshow` 事件，检查 `event.persisted` 属性
  - 如果 `persisted === true`，说明从缓存恢复
  - 需要重新检查页面状态，因为可能已过时

**Q10: 如何处理页面预渲染（prerender）？**

- A: 检测方式：
  - `document.visibilityState === 'prerender'`
  - 在预渲染状态下，某些 API 可能不可用
  - 需要等待页面变为 `visible` 后再进行状态检测

## 四、综合判断策略

### 4.1 状态优先级

1. **高优先级**（必须满足）：
   - `document.readyState === 'complete'`
   - 关键元素存在且可见
   - 无明显的加载指示器

2. **中优先级**（重要指标）：
   - 网络请求稳定（无活跃请求或请求完成）
   - DOM 结构稳定（MutationObserver 检测到稳定期）
   - 框架状态就绪（如果可检测）

3. **低优先级**（辅助判断）：
   - 图片加载完成
   - 字体加载完成
   - 性能指标正常

### 4.2 状态机设计

```
初始状态: UNKNOWN
  ↓
检测到导航: NAVIGATING
  ↓
DOM 解析中: DOM_LOADING
  ↓
DOM 可交互: DOM_READY
  ↓
资源加载中: RESOURCE_LOADING
  ↓
内容稳定中: CONTENT_STABILIZING (SPA 特有)
  ↓
完全就绪: READY
```

#### 状态说明

- **UNKNOWN**: 初始状态，尚未开始检测
- **NAVIGATING**: 检测到页面导航开始（`onBeforeNavigate` 或 `readyState === 'loading'`）
- **DOM_LOADING**: DOM 正在解析（`readyState === 'loading'`）
- **DOM_READY**: DOM 解析完成（`DOMContentLoaded` 或 `readyState === 'interactive'`）
- **RESOURCE_LOADING**: 资源正在加载（`readyState === 'interactive'` 但资源未完成）
- **CONTENT_STABILIZING**: 内容正在稳定（SPA 特有，DOM 变化但趋于稳定）
- **READY**: 完全就绪（所有条件满足）

### 4.3 实现建议

1. **使用组合 Observer**：
   - MutationObserver: DOM 变化
   - IntersectionObserver: 元素可见性
   - PerformanceObserver: 性能指标
   - ResizeObserver: 布局变化

2. **状态聚合**：
   - 收集所有状态指标
   - 使用防抖/节流避免频繁更新
   - 设置稳定期阈值（如 500ms 无变化）

3. **错误处理**：
   - 超时检测（如 30 秒未就绪）
   - 错误状态检测
   - 降级策略（部分指标不可用时）

4. **SPA 特殊处理**：
   - 路由变化检测
   - 框架状态检测
   - 动态内容加载检测

5. **非 SPA 特殊处理**：
   - 完整加载流程追踪
   - iframe 加载检测
   - 传统导航检测

### 4.4 检测算法伪代码

```typescript
function detectPageState() {
  // 1. 基础状态检查
  const readyState = document.readyState;
  const hasKeyElements = checkKeyElements();
  const hasLoadingIndicators = checkLoadingIndicators();
  
  // 2. 网络状态检查
  const networkQuiet = checkNetworkQuiet();
  
  // 3. DOM 稳定性检查
  const domStable = checkDOMStability();
  
  // 4. 资源加载检查
  const resourcesLoaded = checkResourcesLoaded();
  
  // 5. 综合判断
  if (readyState === 'complete' && 
      hasKeyElements && 
      !hasLoadingIndicators && 
      networkQuiet && 
      domStable && 
      resourcesLoaded) {
    return 'READY';
  }
  
  // 6. 根据具体情况返回其他状态
  // ...
}
```

## 五、实现细节

### 5.1 Content Script 实现要点

1. **初始化时机**：
   - 在 `DOMContentLoaded` 后初始化
   - 如果脚本注入较晚，需要检查当前状态

2. **Observer 配置**：
   - MutationObserver: 监听整个文档树，但只关注关键区域
   - IntersectionObserver: 监听关键元素和懒加载区域
   - PerformanceObserver: 监听导航和资源事件

3. **状态同步**：
   - 使用 `chrome.runtime.sendMessage` 向 background 发送状态
   - 使用防抖避免频繁发送

4. **错误处理**：
   - 捕获所有可能的异常
   - 提供降级方案

### 5.2 Background Script 实现要点

1. **事件监听**：
   - `chrome.webNavigation` 事件
   - `chrome.tabs` 事件
   - 来自 content script 的消息

2. **状态管理**：
   - 维护每个 tab 的状态
   - 处理多个 frames 的状态

3. **与 Server 同步**：
   - 状态变化时发送到 server
   - 使用队列避免频繁请求

### 5.3 性能优化

1. **Observer 优化**：
   - 只监听必要的区域
   - 使用 `disconnect()` 及时清理
   - 避免在回调中执行重操作

2. **状态检查优化**：
   - 使用缓存避免重复计算
   - 批量检查多个指标
   - 使用 `requestIdleCallback` 在空闲时检查

3. **通信优化**：
   - 使用防抖/节流
   - 批量发送状态更新
   - 使用 `chrome.storage` 缓存状态
